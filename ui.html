<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Silly Media - Image Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --surface2: #0f3460;
      --accent: #e94560;
      --accent2: #533483;
      --text: #eee;
      --text-dim: #888;
      --success: #4ade80;
      --radius: 8px;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 20px;
    }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }
    h1 { font-size: 1.5rem; margin-bottom: 20px; color: var(--accent); }
    h2 { font-size: 1.1rem; margin-bottom: 12px; color: var(--text-dim); }

    /* Panel styles */
    .panel {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
    }
    .controls { position: sticky; top: 20px; }

    /* Form elements */
    label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 4px;
    }
    textarea, input, select {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--surface2);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      font-size: 0.95rem;
      margin-bottom: 12px;
    }
    textarea { resize: vertical; min-height: 100px; font-family: inherit; }
    textarea:focus, input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Grid layouts */
    .row { display: flex; gap: 12px; }
    .row > * { flex: 1; }

    /* Buttons */
    button {
      padding: 10px 16px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: var(--accent);
      color: white;
      font-weight: 600;
    }
    .btn-primary:hover { filter: brightness(1.1); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary {
      background: var(--surface2);
      color: var(--text);
    }
    .btn-secondary:hover { background: var(--accent2); }
    .btn-small {
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    .btn-danger { background: #dc2626; color: white; }
    .btn-danger:hover { background: #b91c1c; }

    .btn-group { display: flex; gap: 8px; margin-top: 16px; }
    .btn-group button { flex: 1; }

    /* Generate button */
    #generateBtn {
      width: 100%;
      padding: 14px;
      font-size: 1rem;
      margin-top: 8px;
    }

    /* Copy buttons */
    .copy-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .copy-buttons { display: flex; gap: 8px; }
    .copy-buttons button { flex: 1; }

    /* Status */
    .status {
      margin-top: 12px;
      padding: 10px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      display: none;
    }
    .status.error { display: block; background: #dc262633; color: #fca5a5; }
    .status.success { display: block; background: #16a34a33; color: var(--success); }
    .status.loading { display: block; background: var(--surface2); color: var(--text-dim); }

    /* Preview */
    .preview-container {
      background: var(--surface);
      border-radius: var(--radius);
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .preview-container img {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
    }
    .preview-placeholder {
      color: var(--text-dim);
      text-align: center;
    }
    .preview-actions {
      position: absolute;
      bottom: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
    }

    /* Gallery */
    .gallery-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .gallery-header h2 { margin: 0; }
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
    }
    .gallery-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: var(--radius);
      overflow: hidden;
      cursor: pointer;
      background: var(--bg);
    }
    .gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.2s;
    }
    .gallery-item:hover img { transform: scale(1.05); }
    .gallery-item .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .gallery-item:hover .overlay { opacity: 1; }
    .gallery-item.selected { outline: 3px solid var(--accent); }
    .gallery-item .checkbox {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 20px;
      height: 20px;
      background: var(--bg);
      border: 2px solid var(--text-dim);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .gallery-item:hover .checkbox,
    .gallery-item.selected .checkbox { opacity: 1; }
    .gallery-item.selected .checkbox {
      background: var(--accent);
      border-color: var(--accent);
    }
    .gallery-item .name-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      color: white;
      padding: 20px 8px 8px;
      font-size: 0.8rem;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .empty-gallery {
      text-align: center;
      padding: 40px;
      color: var(--text-dim);
    }

    /* Prompt History */
    .history-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .history-item {
      padding: 8px 10px;
      margin-bottom: 4px;
      background: var(--bg);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .history-item:hover { background: var(--surface2); }
    .history-item .prompt-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .history-item .delete-btn {
      opacity: 0;
      padding: 2px 6px;
      font-size: 0.75rem;
    }
    .history-item:hover .delete-btn { opacity: 1; }
    .empty-history {
      text-align: center;
      padding: 20px;
      color: var(--text-dim);
      font-size: 0.85rem;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      z-index: 1000;
      flex-direction: column;
      padding: 20px;
    }
    .modal.open { display: flex; }
    .modal-main {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0;
    }
    .modal-main img {
      max-width: 100%;
      max-height: 100%;
      border-radius: var(--radius);
      object-fit: contain;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 2rem;
      color: white;
      cursor: pointer;
      z-index: 10;
    }
    .modal-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 3rem;
      color: white;
      cursor: pointer;
      padding: 20px;
      user-select: none;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .modal-nav:hover { opacity: 1; }
    .modal-nav.prev { left: 10px; }
    .modal-nav.next { right: 10px; }
    .modal-nav.disabled { opacity: 0.2; cursor: default; }
    .modal-counter {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text-dim);
      font-size: 0.9rem;
    }
    .modal-name-label {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 20px;
      border-radius: var(--radius);
      font-size: 1.1rem;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .modal-info {
      background: var(--surface);
      padding: 12px 16px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      max-height: 20vh;
      overflow-y: auto;
      margin-top: 12px;
    }
    .modal-info pre {
      white-space: pre-wrap;
      word-break: break-all;
      color: var(--text-dim);
      margin: 0;
    }
    .modal-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    /* Thumbnail strip */
    .thumbnail-strip {
      display: flex;
      gap: 8px;
      padding: 12px 0;
      overflow-x: auto;
      justify-content: center;
      flex-wrap: nowrap;
    }
    .thumbnail-strip::-webkit-scrollbar { height: 6px; }
    .thumbnail-strip::-webkit-scrollbar-track { background: var(--bg); }
    .thumbnail-strip::-webkit-scrollbar-thumb { background: var(--surface2); border-radius: 3px; }
    .thumbnail {
      width: 60px;
      height: 60px;
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      flex-shrink: 0;
      opacity: 0.5;
      transition: all 0.2s;
      border: 2px solid transparent;
    }
    .thumbnail:hover { opacity: 0.8; }
    .thumbnail.active {
      opacity: 1;
      border-color: var(--accent);
    }
    .thumbnail {
      position: relative;
    }
    .thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .thumbnail .thumb-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 0.55rem;
      padding: 2px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .thumbnail.thumb-jump,
    .thumbnail.thumb-ellipsis {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      opacity: 0.7;
    }
    .thumbnail.thumb-jump:hover { opacity: 1; }
    .thumbnail.thumb-jump span,
    .thumbnail.thumb-ellipsis span {
      font-size: 0.7rem;
      color: var(--text-dim);
    }
    .thumbnail.thumb-ellipsis {
      cursor: default;
    }

    /* Batch mode */
    .batch-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .batch-section textarea {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.8rem;
      min-height: 120px;
    }
    .json-error {
      background: #dc262633;
      color: #fca5a5;
      padding: 8px 10px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      margin-bottom: 8px;
      display: none;
    }
    .json-error.show { display: block; }
    .json-valid {
      background: #16a34a33;
      color: var(--success);
      padding: 8px 10px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      margin-bottom: 8px;
      display: none;
    }
    .json-valid.show { display: block; }
    .batch-progress {
      background: var(--bg);
      padding: 10px;
      border-radius: var(--radius);
      margin-bottom: 8px;
    }
    .batch-progress-bar {
      height: 6px;
      background: var(--surface2);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .batch-progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s;
    }
    .batch-progress-text {
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    .batch-names {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .batch-names .prev-name,
    .batch-names .next-name {
      color: var(--text-dim);
      font-size: 0.75rem;
    }
    .batch-names .current-name {
      font-weight: 700;
      color: var(--accent);
      font-size: 1rem;
    }
    .batch-names .arrow {
      color: var(--text-dim);
      font-size: 0.7rem;
    }
    .variables-hint {
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-bottom: 8px;
    }
    .variables-hint code {
      background: var(--bg);
      padding: 2px 4px;
      border-radius: 3px;
    }

    /* Gallery folders */
    .gallery-folders {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .folder-tab {
      padding: 6px 12px;
      background: var(--bg);
      border-radius: var(--radius);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .folder-tab:hover { background: var(--surface2); }
    .folder-tab.active {
      background: var(--accent);
      color: white;
    }
    .folder-tab .count {
      opacity: 0.7;
      margin-left: 4px;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    .pagination button {
      min-width: 36px;
    }
    .pagination button.active {
      background: var(--accent);
      color: white;
    }
    .pagination-ellipsis {
      padding: 0 8px;
      color: var(--text-dim);
    }

    /* Lazy loading placeholder */
    .lazy-img {
      background: var(--surface2);
      min-height: 100px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--surface);
      padding: 12px 20px;
      border-radius: var(--radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
      z-index: 1001;
    }
    .toast.show { transform: translateY(0); opacity: 1; }

    /* Range input */
    .range-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .range-row input[type="range"] {
      flex: 1;
      margin: 0;
    }
    .range-row .range-value {
      min-width: 40px;
      text-align: right;
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    /* Collapsible */
    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 8px 0;
      margin-bottom: 8px;
      border-bottom: 1px solid var(--surface2);
    }
    .collapsible-header:hover { color: var(--accent); }
    .collapsible-content { display: none; }
    .collapsible-content.open { display: block; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Controls Panel -->
    <div class="panel controls">
      <h1>Silly Media</h1>

      <label for="prompt">Prompt</label>
      <textarea id="prompt" placeholder="Describe the image you want to generate..."></textarea>

      <div class="collapsible-header" onclick="toggleCollapsible('negativeSection')">
        <label style="margin:0;cursor:pointer">Negative Prompt</label>
        <span id="negativeSection-icon">+</span>
      </div>
      <div id="negativeSection" class="collapsible-content">
        <textarea id="negativePrompt" placeholder="What to avoid..." style="min-height:60px"></textarea>
      </div>

      <label for="aspectRatio">Aspect Ratio</label>
      <select id="aspectRatio">
        <option value="1:1">1:1 (Square)</option>
        <option value="4:5">4:5 (Portrait)</option>
        <option value="3:4">3:4 (Portrait)</option>
        <option value="2:3">2:3 (Portrait)</option>
        <option value="9:16">9:16 (Portrait)</option>
        <option value="5:4">5:4 (Landscape)</option>
        <option value="4:3" selected>4:3 (Landscape)</option>
        <option value="3:2">3:2 (Landscape)</option>
        <option value="16:9">16:9 (Landscape)</option>
        <option value="21:9">21:9 (Ultrawide)</option>
        <option value="custom">Custom Size</option>
      </select>

      <div id="customSize" style="display:none">
        <div class="row">
          <div>
            <label for="width">Width</label>
            <input type="number" id="width" value="1024" min="64" max="2048" step="64">
          </div>
          <div>
            <label for="height">Height</label>
            <input type="number" id="height" value="1024" min="64" max="2048" step="64">
          </div>
        </div>
      </div>

      <div id="baseSizeRow">
        <label for="baseSize">Base Size</label>
        <div class="range-row">
          <input type="range" id="baseSize" min="512" max="2048" step="64" value="1024">
          <span class="range-value" id="baseSizeValue">1024</span>
        </div>
      </div>

      <div class="collapsible-header" onclick="toggleCollapsible('advancedSection')">
        <label style="margin:0;cursor:pointer">Advanced Settings</label>
        <span id="advancedSection-icon">+</span>
      </div>
      <div id="advancedSection" class="collapsible-content">
        <label for="steps">Inference Steps</label>
        <div class="range-row">
          <input type="range" id="steps" min="1" max="50" value="9">
          <span class="range-value" id="stepsValue">9</span>
        </div>

        <label for="cfgScale">CFG Scale</label>
        <div class="range-row">
          <input type="range" id="cfgScale" min="0" max="20" step="0.5" value="0">
          <span class="range-value" id="cfgScaleValue">0</span>
        </div>

        <label for="seed">Seed (-1 for random)</label>
        <input type="number" id="seed" value="-1" min="-1">

        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" value="http://localhost:4201">

        <label for="model">Model</label>
        <input type="text" id="model" value="z-image-turbo">
      </div>

      <button id="generateBtn" class="btn-primary" onclick="generate()">Generate</button>

      <div id="status" class="status"></div>

      <div class="copy-section">
        <label>Copy Request</label>
        <div class="copy-buttons">
          <button class="btn-secondary btn-small" onclick="copyCurl()">cURL</button>
          <button class="btn-secondary btn-small" onclick="copyJson()">JSON</button>
          <button class="btn-secondary btn-small" onclick="copyPython()">Python</button>
        </div>
      </div>

      <div class="history-section">
        <div class="collapsible-header" onclick="toggleCollapsible('historySection')">
          <label style="margin:0;cursor:pointer">Prompt History (<span id="historyCount">0</span>)</label>
          <span id="historySection-icon">+</span>
        </div>
        <div id="historySection" class="collapsible-content">
          <div id="historyList" class="history-list"></div>
          <button class="btn-danger btn-small" onclick="clearHistory()" style="margin-top:8px;width:100%">Clear History</button>
        </div>
      </div>

      <div class="batch-section">
        <div class="collapsible-header" onclick="toggleCollapsible('batchSection')">
          <label style="margin:0;cursor:pointer">Batch Mode</label>
          <span id="batchSection-icon">+</span>
        </div>
        <div id="batchSection" class="collapsible-content">
          <div class="variables-hint">
            Use <code>{variable}</code> in your prompt. JSON array with objects containing any keys.
          </div>
          <textarea id="batchJson" placeholder='[
  {"name": "Character1", "outfit": "Red dress"},
  {"name": "Character2", "outfit": "Blue suit"}
]'></textarea>
          <div id="jsonError" class="json-error"></div>
          <div id="jsonValid" class="json-valid"></div>
          <div id="batchProgress" class="batch-progress" style="display:none">
            <div class="batch-progress-bar">
              <div class="batch-progress-fill" id="batchProgressFill" style="width:0%"></div>
            </div>
            <div class="batch-progress-text" id="batchProgressText">0 / 0</div>
            <div class="batch-names" id="batchNames"></div>
          </div>
          <button id="batchGenerateBtn" class="btn-primary" onclick="generateBatch()" style="width:100%">Generate Batch</button>
          <button id="batchCancelBtn" class="btn-danger" onclick="cancelBatch()" style="width:100%;margin-top:8px;display:none">Cancel Batch</button>
        </div>
      </div>
    </div>

    <!-- Preview & Gallery -->
    <div>
      <div class="preview-container" id="previewContainer">
        <div class="preview-placeholder">
          <p>Generated image will appear here</p>
        </div>
      </div>

      <div class="panel">
        <div class="gallery-header">
          <h2>Gallery (<span id="galleryCount">0</span>)</h2>
          <div>
            <button class="btn-secondary btn-small" onclick="downloadZip()" id="downloadZipBtn">Download ZIP</button>
            <button class="btn-secondary btn-small" onclick="selectAll()" id="selectAllBtn">Select All</button>
            <button class="btn-danger btn-small" onclick="deleteSelected()" id="deleteSelectedBtn" style="display:none">Delete Selected</button>
            <button class="btn-danger btn-small" onclick="clearGallery()">Clear All</button>
          </div>
        </div>
        <div id="galleryFolders" class="gallery-folders"></div>
        <div id="gallery" class="gallery-grid"></div>
        <div id="galleryPagination"></div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal" onclick="closeModal(event)">
    <span class="modal-close" onclick="closeModal()">&times;</span>
    <span class="modal-counter" id="modalCounter">1 / 1</span>

    <div class="modal-main" onclick="event.stopPropagation()">
      <span class="modal-nav prev" id="modalPrev" onclick="navigateModal(-1)">&lsaquo;</span>
      <img id="modalImg" src="">
      <span class="modal-nav next" id="modalNext" onclick="navigateModal(1)">&rsaquo;</span>
      <div class="modal-name-label" id="modalNameLabel" style="display: none;"></div>
    </div>

    <div class="thumbnail-strip" id="thumbnailStrip" onclick="event.stopPropagation()"></div>

    <div class="modal-info" onclick="event.stopPropagation()">
      <pre id="modalInfo"></pre>
      <div class="modal-actions">
        <button class="btn-secondary btn-small" onclick="downloadImage(currentModalId)">Download</button>
        <button class="btn-secondary btn-small" onclick="reuseSettings(currentModalId)">Reuse Settings</button>
        <button class="btn-danger btn-small" onclick="deleteFromModal()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <script>
    // IndexedDB for storing images
    const DB_NAME = 'sillyMediaGallery';
    const DB_VERSION = 2; // Bumped for thumbnail support
    const STORE_NAME = 'images';
    const SETTINGS_KEY = 'sillyMediaSettings';
    const HISTORY_KEY = 'sillyMediaHistory';
    const MAX_HISTORY = 50;
    const THUMB_SIZE = 200; // Thumbnail max dimension
    const PAGE_SIZE = 24; // Images per page
    let db;
    let selectedItems = new Set();
    let currentModalId = null;
    let galleryImages = []; // Cache for carousel navigation
    let currentImageIndex = 0;
    let currentFolder = 'all'; // Current gallery folder filter
    let batchCancelled = false; // Flag to cancel batch generation
    let currentPage = 0; // Current gallery page
    let galleryObserver = null; // IntersectionObserver for lazy loading

    // Initialize
    async function init() {
      db = await openDB();
      loadSavedSettings();
      loadHistory();
      await loadGallery();
      setupEventListeners();
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          }
          // Migration: generate thumbnails for existing images will happen lazily
        };
      });
    }

    // Generate thumbnail from full image data URL
    function generateThumbnail(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let w = img.width, h = img.height;
          if (w > h) {
            if (w > THUMB_SIZE) { h = h * THUMB_SIZE / w; w = THUMB_SIZE; }
          } else {
            if (h > THUMB_SIZE) { w = w * THUMB_SIZE / h; h = THUMB_SIZE; }
          }
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          resolve(canvas.toDataURL('image/jpeg', 0.7));
        };
        img.onerror = () => resolve(dataUrl); // Fallback to full image
        img.src = dataUrl;
      });
    }

    function dbTransaction(mode) {
      return db.transaction(STORE_NAME, mode).objectStore(STORE_NAME);
    }

    async function saveImage(blob, settings, folder = null) {
      const reader = new FileReader();
      const dataUrl = await new Promise((resolve) => {
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });

      // Generate thumbnail
      const thumbnail = await generateThumbnail(dataUrl);

      return new Promise((resolve, reject) => {
        const store = dbTransaction('readwrite');
        const item = {
          data: dataUrl,
          thumbnail,
          settings,
          timestamp: Date.now(),
          folder: folder
        };
        const request = store.add(item);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function getAllImages() {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readonly');
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function deleteImage(id) {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readwrite');
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async function getImage(id) {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readonly');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Settings persistence
    function saveSettings() {
      const settings = {
        prompt: document.getElementById('prompt').value,
        aspectRatio: document.getElementById('aspectRatio').value,
        baseSize: document.getElementById('baseSize').value,
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        steps: document.getElementById('steps').value,
        cfgScale: document.getElementById('cfgScale').value,
        seed: document.getElementById('seed').value,
        apiUrl: document.getElementById('apiUrl').value,
        model: document.getElementById('model').value,
        negativePrompt: document.getElementById('negativePrompt').value,
        batchJson: document.getElementById('batchJson').value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }

    function loadSavedSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;

      try {
        const s = JSON.parse(saved);
        if (s.prompt) document.getElementById('prompt').value = s.prompt;
        if (s.aspectRatio) {
          document.getElementById('aspectRatio').value = s.aspectRatio;
          const custom = s.aspectRatio === 'custom';
          document.getElementById('customSize').style.display = custom ? 'block' : 'none';
          document.getElementById('baseSizeRow').style.display = custom ? 'none' : 'block';
        }
        if (s.baseSize) {
          document.getElementById('baseSize').value = s.baseSize;
          document.getElementById('baseSizeValue').textContent = s.baseSize;
        }
        if (s.width) document.getElementById('width').value = s.width;
        if (s.height) document.getElementById('height').value = s.height;
        if (s.steps) {
          document.getElementById('steps').value = s.steps;
          document.getElementById('stepsValue').textContent = s.steps;
        }
        if (s.cfgScale !== undefined) {
          document.getElementById('cfgScale').value = s.cfgScale;
          document.getElementById('cfgScaleValue').textContent = s.cfgScale;
        }
        if (s.seed) document.getElementById('seed').value = s.seed;
        if (s.apiUrl) document.getElementById('apiUrl').value = s.apiUrl;
        if (s.model) document.getElementById('model').value = s.model;
        if (s.negativePrompt) document.getElementById('negativePrompt').value = s.negativePrompt;
        if (s.batchJson) {
          document.getElementById('batchJson').value = s.batchJson;
          validateBatchJson(); // Validate on load to show status
        }
      } catch (e) {
        console.error('Failed to load settings:', e);
      }
    }

    // Prompt history
    function getHistory() {
      try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
      } catch {
        return [];
      }
    }

    function addToHistory(settings) {
      const history = getHistory();
      // Don't add duplicates (same prompt)
      const existingIndex = history.findIndex(h => h.prompt === settings.prompt);
      if (existingIndex !== -1) {
        history.splice(existingIndex, 1);
      }
      // Add to front
      history.unshift({
        ...settings,
        timestamp: Date.now()
      });
      // Limit size
      while (history.length > MAX_HISTORY) {
        history.pop();
      }
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      loadHistory();
    }

    function loadHistory() {
      const history = getHistory();
      const container = document.getElementById('historyList');
      document.getElementById('historyCount').textContent = history.length;

      if (history.length === 0) {
        container.innerHTML = '<div class="empty-history">No prompt history yet</div>';
        return;
      }

      container.innerHTML = history.map((h, i) => `
        <div class="history-item" onclick="applyHistoryItem(${i})">
          <span class="prompt-text">${escapeHtml(h.prompt)}</span>
          <button class="btn-danger btn-small delete-btn" onclick="event.stopPropagation(); deleteHistoryItem(${i})">x</button>
        </div>
      `).join('');
    }

    function applyHistoryItem(index) {
      const history = getHistory();
      const h = history[index];
      if (!h) return;

      document.getElementById('prompt').value = h.prompt || '';
      document.getElementById('negativePrompt').value = h.negative_prompt || '';

      if (h.num_inference_steps) {
        document.getElementById('steps').value = h.num_inference_steps;
        document.getElementById('stepsValue').textContent = h.num_inference_steps;
      }
      if (h.cfg_scale !== undefined) {
        document.getElementById('cfgScale').value = h.cfg_scale;
        document.getElementById('cfgScaleValue').textContent = h.cfg_scale;
      }
      if (h.seed) {
        document.getElementById('seed').value = h.seed;
      } else {
        document.getElementById('seed').value = -1;
      }

      if (h.width && h.height) {
        document.getElementById('aspectRatio').value = 'custom';
        document.getElementById('customSize').style.display = 'block';
        document.getElementById('baseSizeRow').style.display = 'none';
        document.getElementById('width').value = h.width;
        document.getElementById('height').value = h.height;
      } else if (h.aspect_ratio) {
        document.getElementById('aspectRatio').value = h.aspect_ratio;
        document.getElementById('customSize').style.display = 'none';
        document.getElementById('baseSizeRow').style.display = 'block';
        if (h.base_size) {
          document.getElementById('baseSize').value = h.base_size;
          document.getElementById('baseSizeValue').textContent = h.base_size;
        }
      }

      showToast('Settings loaded from history');
    }

    function deleteHistoryItem(index) {
      const history = getHistory();
      history.splice(index, 1);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      loadHistory();
      showToast('Removed from history');
    }

    function clearHistory() {
      if (!confirm('Clear all prompt history?')) return;
      localStorage.removeItem(HISTORY_KEY);
      loadHistory();
      showToast('History cleared');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // UI Functions
    function setupEventListeners() {
      // Range sliders with auto-save
      document.getElementById('baseSize').oninput = (e) => {
        document.getElementById('baseSizeValue').textContent = e.target.value;
        saveSettings();
      };
      document.getElementById('steps').oninput = (e) => {
        document.getElementById('stepsValue').textContent = e.target.value;
        saveSettings();
      };
      document.getElementById('cfgScale').oninput = (e) => {
        document.getElementById('cfgScaleValue').textContent = e.target.value;
        saveSettings();
      };

      // Aspect ratio change with auto-save
      document.getElementById('aspectRatio').onchange = (e) => {
        const custom = e.target.value === 'custom';
        document.getElementById('customSize').style.display = custom ? 'block' : 'none';
        document.getElementById('baseSizeRow').style.display = custom ? 'none' : 'block';
        saveSettings();
      };

      // Other inputs auto-save
      ['prompt', 'width', 'height', 'seed', 'apiUrl', 'model', 'negativePrompt'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('input', saveSettings);
        el.addEventListener('change', saveSettings);
      });

      // Batch JSON validation and save on input
      document.getElementById('batchJson').addEventListener('input', () => {
        validateBatchJson();
        saveSettings();
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        const modalOpen = document.getElementById('modal').classList.contains('open');

        if (e.key === 'Escape') closeModal();
        if (e.key === 'Enter' && e.ctrlKey && !modalOpen) generate();

        // Carousel navigation
        if (modalOpen) {
          if (e.key === 'ArrowLeft') navigateModal(-1);
          if (e.key === 'ArrowRight') navigateModal(1);
          if (e.key === 'Home') goToImage(0);
          if (e.key === 'End') goToImage(galleryImages.length - 1);
        }
      });
    }

    function toggleCollapsible(id) {
      const content = document.getElementById(id);
      const icon = document.getElementById(id + '-icon');
      const isOpen = content.classList.toggle('open');
      icon.textContent = isOpen ? '−' : '+';
    }

    function getSettings() {
      const aspectRatio = document.getElementById('aspectRatio').value;
      const settings = {
        prompt: document.getElementById('prompt').value,
        negative_prompt: document.getElementById('negativePrompt').value || undefined,
        num_inference_steps: parseInt(document.getElementById('steps').value),
        cfg_scale: parseFloat(document.getElementById('cfgScale').value),
        seed: parseInt(document.getElementById('seed').value)
      };

      if (aspectRatio === 'custom') {
        settings.width = parseInt(document.getElementById('width').value);
        settings.height = parseInt(document.getElementById('height').value);
      } else {
        settings.aspect_ratio = aspectRatio;
        settings.base_size = parseInt(document.getElementById('baseSize').value);
      }

      // Clean up
      if (settings.seed === -1) delete settings.seed;
      if (!settings.negative_prompt) delete settings.negative_prompt;

      return settings;
    }

    function getApiUrl() {
      return document.getElementById('apiUrl').value;
    }

    function getModel() {
      return document.getElementById('model').value;
    }

    async function generate() {
      const prompt = document.getElementById('prompt').value.trim();
      if (!prompt) {
        showStatus('Please enter a prompt', 'error');
        return;
      }

      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      btn.textContent = 'Generating...';
      showStatus('Generating image...', 'loading');

      const settings = getSettings();
      const url = `${getApiUrl()}/generate/${getModel()}`;

      try {
        const start = Date.now();
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(settings)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || error.error || 'Generation failed');
        }

        const blob = await response.blob();
        const elapsed = ((Date.now() - start) / 1000).toFixed(1);

        // Save to gallery and history
        const id = await saveImage(blob, settings);
        addToHistory(settings);
        await loadGallery();

        // Show preview
        const imgUrl = URL.createObjectURL(blob);
        showPreview(imgUrl, id);

        showStatus(`Generated in ${elapsed}s`, 'success');
      } catch (error) {
        showStatus(error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate';
      }
    }

    function showPreview(url, id) {
      const container = document.getElementById('previewContainer');
      container.innerHTML = `
        <img src="${url}" alt="Generated image">
        <div class="preview-actions">
          <button class="btn-secondary btn-small" onclick="downloadImage(${id})">Download</button>
        </div>
      `;
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;
    }

    // Cache for filtered/sorted images
    let filteredImages = [];

    async function loadGallery(resetPage = true) {
      const allImages = await getAllImages();
      const gallery = document.getElementById('gallery');
      const foldersEl = document.getElementById('galleryFolders');

      if (resetPage) currentPage = 0;

      // Get unique folders
      const folders = new Set(['all']);
      allImages.forEach(img => {
        if (img.folder) folders.add(img.folder);
      });

      // Build folder tabs
      if (folders.size > 1) {
        const folderCounts = {};
        folderCounts['all'] = allImages.length;
        allImages.forEach(img => {
          const f = img.folder || 'all';
          folderCounts[f] = (folderCounts[f] || 0) + 1;
        });

        foldersEl.innerHTML = Array.from(folders).map(f => `
          <div class="folder-tab ${currentFolder === f ? 'active' : ''}" onclick="setFolder('${escapeHtml(f)}')">
            ${f === 'all' ? 'All' : escapeHtml(f)}<span class="count">(${folderCounts[f] || 0})</span>
          </div>
        `).join('');
      } else {
        foldersEl.innerHTML = '';
      }

      // Filter images by current folder
      filteredImages = allImages;
      if (currentFolder !== 'all') {
        filteredImages = allImages.filter(img => img.folder === currentFolder);
      }

      // Sort by newest first
      filteredImages.sort((a, b) => b.timestamp - a.timestamp);

      const totalImages = filteredImages.length;
      const totalPages = Math.ceil(totalImages / PAGE_SIZE);
      document.getElementById('galleryCount').textContent = totalImages;

      if (totalImages === 0) {
        gallery.innerHTML = '<div class="empty-gallery">No images yet. Generate some!</div>';
        document.getElementById('galleryPagination').innerHTML = '';
        return;
      }

      // Get current page images
      const start = currentPage * PAGE_SIZE;
      const pageImages = filteredImages.slice(start, start + PAGE_SIZE);

      gallery.innerHTML = pageImages.map(img => {
        const nameLabel = img.settings?._variables?.name;
        const thumbSrc = img.thumbnail || img.data; // Fallback for old images
        return `
        <div class="gallery-item ${selectedItems.has(img.id) ? 'selected' : ''}"
             data-id="${img.id}"
             onclick="toggleSelect(event, ${img.id})"
             ondblclick="openModal(${img.id})">
          <img data-src="${thumbSrc}" alt="Generated image" class="lazy-img">
          <div class="checkbox">${selectedItems.has(img.id) ? '✓' : ''}</div>
          ${nameLabel ? `<div class="name-label">${escapeHtml(nameLabel)}</div>` : ''}
          <div class="overlay">
            <button class="btn-secondary btn-small" onclick="event.stopPropagation(); openModal(${img.id})">View</button>
            <button class="btn-secondary btn-small" onclick="event.stopPropagation(); downloadImage(${img.id})">Save</button>
          </div>
        </div>
      `}).join('');

      // Build pagination
      renderPagination(totalPages);

      // Setup lazy loading
      setupLazyLoading();

      updateDeleteButton();
    }

    function renderPagination(totalPages) {
      const paginationEl = document.getElementById('galleryPagination');
      if (totalPages <= 1) {
        paginationEl.innerHTML = '';
        return;
      }

      let html = '<div class="pagination">';

      // Previous button
      html += `<button class="btn-secondary btn-small" ${currentPage === 0 ? 'disabled' : ''} onclick="goToPage(${currentPage - 1})">←</button>`;

      // Page numbers (show max 7 pages with ellipsis)
      const maxVisible = 7;
      let startPage = Math.max(0, currentPage - Math.floor(maxVisible / 2));
      let endPage = Math.min(totalPages - 1, startPage + maxVisible - 1);
      if (endPage - startPage < maxVisible - 1) {
        startPage = Math.max(0, endPage - maxVisible + 1);
      }

      if (startPage > 0) {
        html += `<button class="btn-secondary btn-small" onclick="goToPage(0)">1</button>`;
        if (startPage > 1) html += `<span class="pagination-ellipsis">...</span>`;
      }

      for (let i = startPage; i <= endPage; i++) {
        html += `<button class="btn-secondary btn-small ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i + 1}</button>`;
      }

      if (endPage < totalPages - 1) {
        if (endPage < totalPages - 2) html += `<span class="pagination-ellipsis">...</span>`;
        html += `<button class="btn-secondary btn-small" onclick="goToPage(${totalPages - 1})">${totalPages}</button>`;
      }

      // Next button
      html += `<button class="btn-secondary btn-small" ${currentPage === totalPages - 1 ? 'disabled' : ''} onclick="goToPage(${currentPage + 1})">→</button>`;

      html += '</div>';
      paginationEl.innerHTML = html;
    }

    function goToPage(page) {
      currentPage = page;
      loadGallery(false);
      document.getElementById('gallery').scrollIntoView({ behavior: 'smooth' });
    }

    function setupLazyLoading() {
      // Disconnect old observer
      if (galleryObserver) galleryObserver.disconnect();

      galleryObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              img.classList.remove('lazy-img');
              galleryObserver.unobserve(img);
            }
          }
        });
      }, { rootMargin: '100px' });

      document.querySelectorAll('.lazy-img').forEach(img => {
        galleryObserver.observe(img);
      });
    }

    function setFolder(folder) {
      currentFolder = folder;
      currentPage = 0;
      selectedItems.clear();
      loadGallery();
    }

    function toggleSelect(event, id) {
      if (event.detail === 2) return; // Ignore double clicks

      if (selectedItems.has(id)) {
        selectedItems.delete(id);
      } else {
        selectedItems.add(id);
      }
      loadGallery();
    }

    function selectAll() {
      const gallery = document.getElementById('gallery');
      const items = gallery.querySelectorAll('.gallery-item');

      if (selectedItems.size === items.length) {
        selectedItems.clear();
      } else {
        items.forEach(item => selectedItems.add(parseInt(item.dataset.id)));
      }
      loadGallery();
    }

    function updateDeleteButton() {
      const btn = document.getElementById('deleteSelectedBtn');
      btn.style.display = selectedItems.size > 0 ? 'inline-block' : 'none';
      btn.textContent = `Delete (${selectedItems.size})`;
    }

    async function deleteSelected() {
      if (selectedItems.size === 0) return;
      if (!confirm(`Delete ${selectedItems.size} image(s)?`)) return;

      for (const id of selectedItems) {
        await deleteImage(id);
      }
      selectedItems.clear();
      await loadGallery();
      showToast('Images deleted');
    }

    async function clearGallery() {
      const images = await getAllImages();
      if (images.length === 0) return;
      if (!confirm(`Delete all ${images.length} image(s)?`)) return;

      for (const img of images) {
        await deleteImage(img.id);
      }
      selectedItems.clear();
      await loadGallery();
      showToast('Gallery cleared');
    }

    async function openModal(id) {
      // Get all images for carousel, filtered by current folder
      let allImages = await getAllImages();
      allImages.sort((a, b) => b.timestamp - a.timestamp);

      // Filter by current folder
      if (currentFolder !== 'all') {
        galleryImages = allImages.filter(img => img.folder === currentFolder);
      } else {
        galleryImages = allImages;
      }

      // Find current index
      currentImageIndex = galleryImages.findIndex(img => img.id === id);
      if (currentImageIndex === -1) return;

      currentModalId = id;
      updateModalDisplay();
      buildThumbnailStrip();
      document.getElementById('modal').classList.add('open');
      document.body.style.overflow = 'hidden';
    }

    function updateModalDisplay() {
      const img = galleryImages[currentImageIndex];
      if (!img) return;

      currentModalId = img.id;
      document.getElementById('modalImg').src = img.data;
      document.getElementById('modalInfo').textContent = JSON.stringify(img.settings, null, 2);
      document.getElementById('modalCounter').textContent = `${currentImageIndex + 1} / ${galleryImages.length}`;

      // Update name label
      const nameLabel = img.settings?._variables?.name;
      const nameLabelEl = document.getElementById('modalNameLabel');
      if (nameLabel) {
        nameLabelEl.textContent = nameLabel;
        nameLabelEl.style.display = 'block';
      } else {
        nameLabelEl.style.display = 'none';
      }

      // Update nav buttons
      document.getElementById('modalPrev').classList.toggle('disabled', currentImageIndex === 0);
      document.getElementById('modalNext').classList.toggle('disabled', currentImageIndex === galleryImages.length - 1);

      // For large galleries, rebuild the window; for small, just update active state
      if (galleryImages.length > THUMB_WINDOW * 2) {
        updateThumbnailWindow();
      } else {
        // Update active thumbnail
        document.querySelectorAll('.thumbnail').forEach((thumb, i) => {
          thumb.classList.toggle('active', i === currentImageIndex);
        });

        // Scroll thumbnail into view
        const activeThumb = document.querySelector('.thumbnail.active');
        if (activeThumb) {
          activeThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      }
    }

    const THUMB_WINDOW = 21; // Show 21 thumbnails at a time (10 on each side + current)

    function buildThumbnailStrip() {
      const strip = document.getElementById('thumbnailStrip');
      const total = galleryImages.length;

      // For small galleries, render all
      if (total <= THUMB_WINDOW * 2) {
        strip.innerHTML = galleryImages.map((img, i) => {
          const nameLabel = img.settings?._variables?.name;
          const thumbSrc = img.thumbnail || img.data;
          return `
          <div class="thumbnail ${i === currentImageIndex ? 'active' : ''}" onclick="goToImage(${i})">
            <img src="${thumbSrc}" alt="">
            ${nameLabel ? `<div class="thumb-name">${escapeHtml(nameLabel)}</div>` : ''}
          </div>
        `}).join('');
        return;
      }

      // For large galleries, use windowed rendering
      updateThumbnailWindow();
    }

    function updateThumbnailWindow() {
      const strip = document.getElementById('thumbnailStrip');
      const total = galleryImages.length;
      if (total <= THUMB_WINDOW * 2) return; // Let buildThumbnailStrip handle small galleries

      const halfWindow = Math.floor(THUMB_WINDOW / 2);
      let start = Math.max(0, currentImageIndex - halfWindow);
      let end = Math.min(total, currentImageIndex + halfWindow + 1);

      // Adjust window if at edges
      if (start === 0) end = Math.min(total, THUMB_WINDOW);
      if (end === total) start = Math.max(0, total - THUMB_WINDOW);

      let html = '';

      // Show "jump to start" button if not at beginning
      if (start > 0) {
        html += `<div class="thumbnail thumb-jump" onclick="goToImage(0)"><span>1</span></div>`;
        if (start > 1) html += `<div class="thumbnail thumb-ellipsis"><span>...</span></div>`;
      }

      // Render visible thumbnails
      for (let i = start; i < end; i++) {
        const img = galleryImages[i];
        const nameLabel = img.settings?._variables?.name;
        const thumbSrc = img.thumbnail || img.data;
        html += `
          <div class="thumbnail ${i === currentImageIndex ? 'active' : ''}" onclick="goToImage(${i})">
            <img src="${thumbSrc}" alt="">
            ${nameLabel ? `<div class="thumb-name">${escapeHtml(nameLabel)}</div>` : ''}
          </div>
        `;
      }

      // Show "jump to end" button if not at end
      if (end < total) {
        if (end < total - 1) html += `<div class="thumbnail thumb-ellipsis"><span>...</span></div>`;
        html += `<div class="thumbnail thumb-jump" onclick="goToImage(${total - 1})"><span>${total}</span></div>`;
      }

      strip.innerHTML = html;
    }

    function navigateModal(direction) {
      const newIndex = currentImageIndex + direction;
      if (newIndex < 0 || newIndex >= galleryImages.length) return;
      currentImageIndex = newIndex;
      updateModalDisplay();
    }

    function goToImage(index) {
      if (index < 0 || index >= galleryImages.length) return;
      currentImageIndex = index;
      updateModalDisplay();
    }

    function closeModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('modal').classList.remove('open');
      document.body.style.overflow = '';
      currentModalId = null;
      galleryImages = [];
    }

    async function deleteFromModal() {
      if (!currentModalId) return;
      if (!confirm('Delete this image?')) return;

      await deleteImage(currentModalId);
      galleryImages = galleryImages.filter(img => img.id !== currentModalId);

      if (galleryImages.length === 0) {
        closeModal();
      } else {
        // Stay at same index or go to previous if at end
        if (currentImageIndex >= galleryImages.length) {
          currentImageIndex = galleryImages.length - 1;
        }
        updateModalDisplay();
        buildThumbnailStrip();
      }

      await loadGallery();
      showToast('Image deleted');
    }

    async function reuseSettings(id) {
      const img = await getImage(id);
      if (!img) return;

      const s = img.settings;
      document.getElementById('prompt').value = s.prompt || '';
      document.getElementById('negativePrompt').value = s.negative_prompt || '';
      document.getElementById('steps').value = s.num_inference_steps || 9;
      document.getElementById('stepsValue').textContent = s.num_inference_steps || 9;
      document.getElementById('cfgScale').value = s.cfg_scale || 5;
      document.getElementById('cfgScaleValue').textContent = s.cfg_scale || 5;
      document.getElementById('seed').value = s.seed || -1;

      if (s.width && s.height) {
        document.getElementById('aspectRatio').value = 'custom';
        document.getElementById('customSize').style.display = 'block';
        document.getElementById('baseSizeRow').style.display = 'none';
        document.getElementById('width').value = s.width;
        document.getElementById('height').value = s.height;
      } else if (s.aspect_ratio) {
        document.getElementById('aspectRatio').value = s.aspect_ratio;
        document.getElementById('customSize').style.display = 'none';
        document.getElementById('baseSizeRow').style.display = 'block';
        if (s.base_size) {
          document.getElementById('baseSize').value = s.base_size;
          document.getElementById('baseSizeValue').textContent = s.base_size;
        }
      }

      closeModal();
      showToast('Settings applied');
    }

    async function downloadImage(id) {
      const img = await getImage(id);
      if (!img) return;

      const link = document.createElement('a');
      link.href = img.data;

      // Determine filename: use {name} variable if available, otherwise timestamp
      const name = img.settings?._variables?.name;
      const ext = img.data.startsWith('data:image/png') ? 'png' :
                  img.data.startsWith('data:image/jpeg') ? 'jpg' :
                  img.data.startsWith('data:image/webp') ? 'webp' : 'png';

      if (name) {
        // Sanitize filename (remove invalid characters)
        const safeName = name.replace(/[<>:"/\\|?*]/g, '_').trim();
        link.download = `${safeName}.${ext}`;
      } else {
        const timestamp = new Date(img.timestamp).toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `silly-media-${timestamp}.${ext}`;
      }

      link.click();
      showToast('Image downloaded');
    }

    async function downloadZip() {
      // Get images for current folder
      const allImages = await getAllImages();
      let images = allImages;

      if (currentFolder !== 'all') {
        images = allImages.filter(img => img.folder === currentFolder);
      }

      if (images.length === 0) {
        showToast('No images to download');
        return;
      }

      const btn = document.getElementById('downloadZipBtn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Creating ZIP...';

      try {
        const zip = new JSZip();
        const usedNames = new Map(); // Track used filenames for uniqueness

        for (let i = 0; i < images.length; i++) {
          const img = images[i];

          // Update progress
          btn.textContent = `Zipping ${i + 1}/${images.length}...`;

          // Determine extension from data URL
          const ext = img.data.startsWith('data:image/png') ? 'png' :
                      img.data.startsWith('data:image/jpeg') ? 'jpg' :
                      img.data.startsWith('data:image/webp') ? 'webp' : 'png';

          // Determine base filename
          const name = img.settings?._variables?.name;
          let baseName;
          if (name) {
            baseName = name.replace(/[<>:"/\\|?*]/g, '_').trim();
          } else {
            const timestamp = new Date(img.timestamp).toISOString().replace(/[:.]/g, '-').slice(0, 19);
            baseName = `silly-media-${timestamp}`;
          }

          // Make filename unique
          let filename = `${baseName}.${ext}`;
          const count = usedNames.get(filename) || 0;
          if (count > 0) {
            filename = `${baseName}_${count}.${ext}`;
          }
          usedNames.set(`${baseName}.${ext}`, count + 1);

          // Convert data URL to blob
          const base64Data = img.data.split(',')[1];
          zip.file(filename, base64Data, { base64: true });
        }

        btn.textContent = 'Generating ZIP...';

        const content = await zip.generateAsync({ type: 'blob' }, (metadata) => {
          btn.textContent = `Compressing ${Math.round(metadata.percent)}%...`;
        });

        // Download the ZIP
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        const folderName = currentFolder === 'all' ? 'all-images' : currentFolder.replace(/[<>:"/\\|?*]/g, '_');
        link.download = `${folderName}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);

        showToast(`Downloaded ${images.length} images as ZIP`);
      } catch (error) {
        console.error('ZIP creation failed:', error);
        showToast('Failed to create ZIP');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    // Copy functions
    function copyCurl() {
      const settings = getSettings();
      const url = `${getApiUrl()}/generate/${getModel()}`;
      const json = JSON.stringify(settings);
      const curl = `curl -X POST "${url}" \\
  -H "Content-Type: application/json" \\
  -d '${json}' \\
  --output image.png`;

      copyToClipboard(curl);
    }

    function copyJson() {
      const settings = getSettings();
      copyToClipboard(JSON.stringify(settings, null, 2));
    }

    function copyPython() {
      const settings = getSettings();
      const url = `${getApiUrl()}/generate/${getModel()}`;
      const code = `import requests

response = requests.post(
    "${url}",
    json=${JSON.stringify(settings, null, 4).replace(/"/g, '"')}
)

with open("image.png", "wb") as f:
    f.write(response.content)`;

      copyToClipboard(code);
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Copied to clipboard');
      });
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }

    // Batch generation
    function validateBatchJson() {
      const textarea = document.getElementById('batchJson');
      const errorEl = document.getElementById('jsonError');
      const validEl = document.getElementById('jsonValid');
      const text = textarea.value.trim();

      errorEl.classList.remove('show');
      validEl.classList.remove('show');

      if (!text) return null;

      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data)) {
          throw new Error('JSON must be an array of objects');
        }
        if (data.length === 0) {
          throw new Error('Array is empty');
        }
        if (!data.every(item => typeof item === 'object' && item !== null && !Array.isArray(item))) {
          throw new Error('Each item must be an object');
        }

        // Get all variable names
        const allKeys = new Set();
        data.forEach(item => Object.keys(item).forEach(k => allKeys.add(k)));

        validEl.textContent = `Valid JSON: ${data.length} items with variables: ${Array.from(allKeys).join(', ')}`;
        validEl.classList.add('show');
        return data;
      } catch (e) {
        let message = e.message;
        // Try to provide more helpful error for JSON syntax errors
        if (e instanceof SyntaxError) {
          const match = e.message.match(/position (\d+)/);
          if (match) {
            const pos = parseInt(match[1]);
            const lines = text.substring(0, pos).split('\n');
            message = `Syntax error at line ${lines.length}, column ${lines[lines.length-1].length + 1}: ${e.message}`;
          }
        }
        errorEl.textContent = message;
        errorEl.classList.add('show');
        return null;
      }
    }

    function interpolatePrompt(template, variables, batchData = null, currentIndex = 0) {
      // Match {variable} or {variable+N} or {variable-N}
      return template.replace(/\{(\w+)([+-]\d+)?\}/g, (match, key, offset) => {
        if (offset && batchData) {
          // Relative reference like {name+1} or {name-1}
          const offsetNum = parseInt(offset, 10);
          const total = batchData.length;
          // Circular index: wrap around to beginning/end
          const targetIndex = ((currentIndex + offsetNum) % total + total) % total;
          const targetVars = batchData[targetIndex];
          return targetVars?.hasOwnProperty(key) ? targetVars[key] : match;
        }
        // Regular reference like {name}
        return variables.hasOwnProperty(key) ? variables[key] : match;
      });
    }

    async function generateBatch() {
      const batchData = validateBatchJson();
      if (!batchData) {
        showStatus('Please enter valid JSON', 'error');
        return;
      }

      const promptTemplate = document.getElementById('prompt').value.trim();
      if (!promptTemplate) {
        showStatus('Please enter a prompt template with {variables}', 'error');
        return;
      }

      // Create a folder name for this batch
      const folderName = `Batch ${new Date().toLocaleString()}`;

      const btn = document.getElementById('batchGenerateBtn');
      const cancelBtn = document.getElementById('batchCancelBtn');
      const progressEl = document.getElementById('batchProgress');
      const progressFill = document.getElementById('batchProgressFill');
      const progressText = document.getElementById('batchProgressText');
      const batchNamesEl = document.getElementById('batchNames');

      btn.style.display = 'none';
      cancelBtn.style.display = 'block';
      progressEl.style.display = 'block';
      batchCancelled = false;

      const total = batchData.length;
      let completed = 0;

      // Helper to update batch names display
      function updateBatchNames(index) {
        const prev = index > 0 ? batchData[index - 1]?.name : null;
        const current = batchData[index]?.name;
        const next = index < batchData.length - 1 ? batchData[index + 1]?.name : null;

        if (current) {
          let html = '';
          if (prev) html += `<span class="prev-name">${escapeHtml(prev)}</span><span class="arrow">→</span>`;
          html += `<span class="current-name">${escapeHtml(current)}</span>`;
          if (next) html += `<span class="arrow">→</span><span class="next-name">${escapeHtml(next)}</span>`;
          batchNamesEl.innerHTML = html;
        } else {
          batchNamesEl.innerHTML = '';
        }
      }

      for (let i = 0; i < batchData.length; i++) {
        if (batchCancelled) {
          showStatus(`Batch cancelled after ${completed} images`, 'error');
          break;
        }

        const variables = batchData[i];
        const prompt = interpolatePrompt(promptTemplate, variables, batchData, i);
        const negativeTemplate = document.getElementById('negativePrompt').value;
        const negativePrompt = interpolatePrompt(negativeTemplate, variables, batchData, i);

        progressText.textContent = `${i + 1} / ${total}`;
        progressFill.style.width = `${(i / total) * 100}%`;
        updateBatchNames(i);

        const settings = getSettings();
        settings.prompt = prompt;
        if (negativePrompt) settings.negative_prompt = negativePrompt;
        settings._variables = variables; // Store variables for name display

        const url = `${getApiUrl()}/generate/${getModel()}`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || error.error || 'Generation failed');
          }

          const blob = await response.blob();

          // Save with folder
          await saveImage(blob, settings, folderName);
          completed++;

          // Update progress
          progressFill.style.width = `${((i + 1) / total) * 100}%`;

          // Show preview
          const imgUrl = URL.createObjectURL(blob);
          showPreview(imgUrl, null);

          // Debounce between generations to let GPU breathe
          if (i < batchData.length - 1) {
            await new Promise(r => setTimeout(r, 500));
          }

        } catch (error) {
          console.error(`Failed to generate image ${i + 1}:`, error);
          showStatus(`Error on image ${i + 1}: ${error.message}`, 'error');
          // Continue with next image instead of stopping
        }
      }

      btn.style.display = 'block';
      cancelBtn.style.display = 'none';
      progressEl.style.display = 'none';
      batchNamesEl.innerHTML = '';

      if (!batchCancelled) {
        showStatus(`Batch complete: ${completed}/${total} images`, 'success');
      }

      await loadGallery();
      // Switch to the new folder
      currentFolder = folderName;
      await loadGallery();
    }

    function cancelBatch() {
      batchCancelled = true;
      document.getElementById('batchCancelBtn').textContent = 'Cancelling...';
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
