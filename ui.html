<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Silly Media - Image Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --surface2: #0f3460;
      --accent: #e94560;
      --accent2: #533483;
      --text: #eee;
      --text-dim: #888;
      --success: #4ade80;
      --radius: 8px;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 20px;
    }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }
    h1 { font-size: 1.5rem; margin-bottom: 20px; color: var(--accent); }
    h2 { font-size: 1.1rem; margin-bottom: 12px; color: var(--text-dim); }

    /* Panel styles */
    .panel {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
    }
    .controls { position: sticky; top: 20px; }

    /* Form elements */
    label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 4px;
    }
    textarea, input, select {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--surface2);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      font-size: 0.95rem;
      margin-bottom: 12px;
    }
    textarea { resize: vertical; min-height: 100px; font-family: inherit; }
    textarea:focus, input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Grid layouts */
    .row { display: flex; gap: 12px; }
    .row > * { flex: 1; }

    /* Buttons */
    button {
      padding: 10px 16px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: var(--accent);
      color: white;
      font-weight: 600;
    }
    .btn-primary:hover { filter: brightness(1.1); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary {
      background: var(--surface2);
      color: var(--text);
    }
    .btn-secondary:hover { background: var(--accent2); }
    .btn-small {
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    .btn-danger { background: #dc2626; color: white; }
    .btn-danger:hover { background: #b91c1c; }

    .btn-group { display: flex; gap: 8px; margin-top: 16px; }
    .btn-group button { flex: 1; }

    /* Generate button */
    #generateBtn {
      width: 100%;
      padding: 14px;
      font-size: 1rem;
      margin-top: 8px;
    }

    /* Copy buttons */
    .copy-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .copy-buttons { display: flex; gap: 8px; }
    .copy-buttons button { flex: 1; }

    /* Status */
    .status {
      margin-top: 12px;
      padding: 10px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      display: none;
    }
    .status.error { display: block; background: #dc262633; color: #fca5a5; }
    .status.success { display: block; background: #16a34a33; color: var(--success); }
    .status.loading { display: block; background: var(--surface2); color: var(--text-dim); }

    /* Preview */
    .preview-container {
      background: var(--surface);
      border-radius: var(--radius);
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .preview-container img {
      max-width: 100%;
      max-height: 70vh;
      object-fit: contain;
    }
    .preview-placeholder {
      color: var(--text-dim);
      text-align: center;
    }
    .preview-actions {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 8px;
    }
    .debounce-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(0,0,0,0.3);
      z-index: 10;
    }
    .debounce-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #a78bfa);
      border-radius: 0 2px 2px 0;
      transition: none;
    }
    .debounce-bar-fill.animate {
      animation: debounceProgress var(--debounce-duration, 1000ms) linear forwards;
    }
    @keyframes debounceProgress {
      from { width: 0%; }
      to { width: 100%; }
    }
    .preview-prompt {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.85));
      color: white;
      padding: 30px 12px 12px;
      font-size: 0.8rem;
      line-height: 1.4;
      max-height: 30%;
      overflow-y: auto;
    }
    .preview-prompt::-webkit-scrollbar { width: 4px; }
    .preview-prompt::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 2px; }
    .preview-prompt .var-json {
      color: #ff6b9d;
      font-weight: 600;
    }
    .preview-prompt .var-ref {
      color: #a78bfa;
      font-weight: 600;
    }
    .preview-prompt .var-builtin {
      color: #4ade80;
      font-weight: 600;
    }

    /* Gallery */
    .gallery-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .gallery-header h2 { margin: 0; }
    .gallery-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 12px;
    }
    .gallery-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: var(--radius);
      overflow: hidden;
      cursor: pointer;
      background: var(--bg);
    }
    .gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.2s;
    }
    .gallery-item:hover img { transform: scale(1.05); }
    .gallery-item .overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .gallery-item:hover .overlay { opacity: 1; }
    .gallery-item.selected { outline: 3px solid var(--accent); }
    .gallery-item .checkbox {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 20px;
      height: 20px;
      background: var(--bg);
      border: 2px solid var(--text-dim);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .gallery-item:hover .checkbox,
    .gallery-item.selected .checkbox { opacity: 1; }
    .gallery-item.selected .checkbox {
      background: var(--accent);
      border-color: var(--accent);
    }
    .gallery-item .name-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      color: white;
      padding: 20px 8px 8px;
      font-size: 0.8rem;
      text-align: center;
      pointer-events: none;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8);
    }

    .empty-gallery {
      text-align: center;
      padding: 40px;
      color: var(--text-dim);
    }

    /* Prompt History */
    .history-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .history-list {
      max-height: 200px;
      overflow-y: auto;
    }
    .history-item {
      padding: 8px 10px;
      margin-bottom: 4px;
      background: var(--bg);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 0.85rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .history-item:hover { background: var(--surface2); }
    .history-item .prompt-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .history-item .delete-btn {
      opacity: 0;
      padding: 2px 6px;
      font-size: 0.75rem;
    }
    .history-item:hover .delete-btn { opacity: 1; }
    .history-item .fav-btn {
      opacity: 0.3;
      background: none;
      border: none;
      cursor: pointer;
      padding: 2px;
      font-size: 0.9rem;
      color: var(--text);
      transition: opacity 0.15s;
    }
    .history-item:hover .fav-btn { opacity: 0.7; }
    .history-item .fav-btn.active { opacity: 1; color: gold; }
    .history-item .fav-btn:hover { opacity: 1; }
    .empty-history {
      text-align: center;
      padding: 20px;
      color: var(--text-dim);
      font-size: 0.85rem;
    }
    .save-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 6px;
      font-size: 1rem;
      color: var(--text-dim);
      opacity: 0.7;
      transition: opacity 0.15s, color 0.15s;
    }
    .save-btn:hover { opacity: 1; color: var(--accent); }
    .label-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      z-index: 1000;
      flex-direction: column;
      padding: 20px;
    }
    .modal.open { display: flex; }
    .modal-main {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 0;
    }
    .modal-main img {
      max-width: 100%;
      max-height: 100%;
      border-radius: var(--radius);
      object-fit: contain;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 2rem;
      color: white;
      cursor: pointer;
      z-index: 10;
    }
    .modal-nav {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 3rem;
      color: white;
      cursor: pointer;
      padding: 20px;
      user-select: none;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .modal-nav:hover { opacity: 1; }
    .modal-nav.prev { left: 10px; }
    .modal-nav.next { right: 10px; }
    .modal-nav.disabled { opacity: 0.2; cursor: default; }
    .modal-counter {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--text-dim);
      font-size: 0.9rem;
    }
    .modal-name-label {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 20px;
      border-radius: var(--radius);
      font-size: 1.1rem;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .modal-prompt {
      background: var(--surface);
      padding: 10px 16px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      line-height: 1.5;
      margin-top: 8px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }
    .modal-prompt .var-json {
      color: #ff6b9d;
      font-weight: 600;
    }
    .modal-prompt .var-ref {
      color: #a78bfa;
      font-weight: 600;
    }
    .modal-prompt .var-builtin {
      color: #4ade80;
      font-weight: 600;
    }
    .modal-info {
      background: var(--surface);
      padding: 12px 16px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      max-height: 20vh;
      overflow-y: auto;
      margin-top: 12px;
    }
    .modal-info pre {
      white-space: pre-wrap;
      word-break: break-all;
      color: var(--text-dim);
      margin: 0;
    }
    .modal-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
    }

    /* Thumbnail strip */
    .thumbnail-strip {
      display: flex;
      gap: 8px;
      padding: 12px 0;
      overflow-x: auto;
      justify-content: center;
      flex-wrap: nowrap;
    }
    .thumbnail-strip::-webkit-scrollbar { height: 6px; }
    .thumbnail-strip::-webkit-scrollbar-track { background: var(--bg); }
    .thumbnail-strip::-webkit-scrollbar-thumb { background: var(--surface2); border-radius: 3px; }
    .thumbnail {
      width: 60px;
      height: 60px;
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      flex-shrink: 0;
      opacity: 0.5;
      transition: all 0.2s;
      border: 2px solid transparent;
    }
    .thumbnail:hover { opacity: 0.8; }
    .thumbnail.active {
      opacity: 1;
      border-color: var(--accent);
    }
    .thumbnail {
      position: relative;
    }
    .thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .thumbnail .thumb-name {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 0.55rem;
      padding: 2px;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .thumbnail.thumb-jump,
    .thumbnail.thumb-ellipsis {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      opacity: 0.7;
    }
    .thumbnail.thumb-jump:hover { opacity: 1; }
    .thumbnail.thumb-jump span,
    .thumbnail.thumb-ellipsis span {
      font-size: 0.7rem;
      color: var(--text-dim);
    }
    .thumbnail.thumb-ellipsis {
      cursor: default;
    }

    /* Batch mode */
    .batch-section {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--surface2);
    }
    .batch-section textarea {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.8rem;
      min-height: 120px;
    }
    .json-error {
      background: #dc262633;
      color: #fca5a5;
      padding: 8px 10px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      margin-bottom: 8px;
      display: none;
    }
    .json-error.show { display: block; }
    .json-valid {
      background: #16a34a33;
      color: var(--success);
      padding: 8px 10px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      margin-bottom: 8px;
      display: none;
    }
    .json-valid.show { display: block; }
    .batch-progress {
      background: var(--bg);
      padding: 10px;
      border-radius: var(--radius);
      margin-bottom: 8px;
    }
    .batch-progress-bar {
      height: 6px;
      background: var(--surface2);
      border-radius: 3px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .batch-progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s;
    }
    .batch-progress-text {
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    .batch-names {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .batch-names .prev-name,
    .batch-names .next-name,
    .batch-names .ref-name {
      color: var(--text-dim);
      font-size: 0.85rem;
    }
    .batch-names .ref-name sup {
      font-size: 0.6rem;
      color: var(--accent2);
    }
    .batch-names .current-name {
      font-weight: 700;
      color: var(--accent);
      font-size: 1rem;
    }
    .batch-names .arrow {
      color: var(--text-dim);
      font-size: 0.7rem;
      margin: 0 2px;
    }
    .batch-prompt {
      margin-top: 8px;
      padding: 8px 10px;
      background: var(--bg);
      border-radius: var(--radius);
      font-size: 0.75rem;
      color: var(--text);
      line-height: 1.4;
      max-height: 60px;
      overflow-y: auto;
    }
    .variables-hint {
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-bottom: 8px;
    }
    .variables-hint code {
      background: var(--bg);
      padding: 2px 4px;
      border-radius: 3px;
    }
    .help-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: var(--accent);
      color: white;
      border-radius: 50%;
      font-size: 0.7rem;
      font-weight: bold;
      cursor: pointer;
      margin-left: 4px;
    }
    .help-icon:hover { filter: brightness(1.2); }

    /* Help Modal */
    .help-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .help-modal.open { display: flex; }
    .help-content {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 24px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    .help-content h3 {
      color: var(--accent);
      margin-bottom: 16px;
    }
    .help-content h4 {
      color: var(--text);
      margin: 16px 0 8px;
      font-size: 0.95rem;
    }
    .help-content p {
      color: var(--text-dim);
      font-size: 0.85rem;
      margin-bottom: 8px;
    }
    .help-content pre {
      background: var(--bg);
      padding: 12px;
      border-radius: var(--radius);
      font-size: 0.8rem;
      overflow-x: auto;
      margin-bottom: 8px;
    }
    .help-content code {
      background: var(--bg);
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--accent);
    }
    .help-content table {
      width: 100%;
      font-size: 0.8rem;
      margin: 8px 0;
    }
    .help-content td {
      padding: 6px 8px;
      border-bottom: 1px solid var(--surface2);
    }
    .help-content td:first-child {
      white-space: nowrap;
    }
    .help-close {
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 1.5rem;
      color: var(--text-dim);
      cursor: pointer;
    }
    .help-close:hover { color: var(--text); }

    /* Settings modal */
    .settings-modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .settings-modal.open { display: flex; }
    .settings-content {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 24px;
      min-width: 300px;
      max-width: 400px;
      position: relative;
    }
    .settings-content h3 {
      color: var(--accent);
      margin-bottom: 16px;
    }
    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--surface2);
    }
    .settings-row:last-child {
      border-bottom: none;
    }
    .settings-row label {
      font-size: 0.9rem;
      color: var(--text);
    }
    .settings-row select {
      padding: 6px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text);
      font-size: 0.85rem;
    }
    .settings-icon {
      cursor: pointer;
      color: var(--text-dim);
      font-size: 1.2rem;
      margin-left: 12px;
      transition: color 0.2s;
    }
    .settings-icon:hover { color: var(--accent); }
    .header-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .header-row h1 { margin: 0; }

    /* Gallery folders */
    .gallery-folders {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .folder-tab {
      padding: 6px 12px;
      background: var(--bg);
      border-radius: var(--radius);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .folder-tab:hover { background: var(--surface2); }
    .folder-tab.active {
      background: var(--accent);
      color: white;
    }
    .folder-tab .count {
      opacity: 0.7;
      margin-left: 4px;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    .pagination button {
      min-width: 36px;
    }
    .pagination button.active {
      background: var(--accent);
      color: white;
    }
    .pagination-ellipsis {
      padding: 0 8px;
      color: var(--text-dim);
    }

    /* Lazy loading placeholder */
    .lazy-img {
      background: var(--surface2);
      min-height: 100px;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--surface);
      padding: 12px 20px;
      border-radius: var(--radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s;
      z-index: 1001;
    }
    .toast.show { transform: translateY(0); opacity: 1; }

    /* Range input */
    .range-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .range-row input[type="range"] {
      flex: 1;
      margin: 0;
    }
    .range-row .range-value {
      min-width: 40px;
      text-align: right;
      font-size: 0.85rem;
      color: var(--text-dim);
    }

    /* Collapsible */
    .collapsible-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
      padding: 8px 0;
      margin-bottom: 8px;
      border-bottom: 1px solid var(--surface2);
    }
    .collapsible-header:hover { color: var(--accent); }
    .collapsible-header.small {
      padding: 4px 0;
      margin-bottom: 4px;
      margin-top: 8px;
    }
    .collapsible-content { display: none; }
    .collapsible-content.open { display: block; }
    .neg-history-section {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--surface2);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Controls Panel -->
    <div class="panel controls">
      <div class="header-row">
        <h1>Silly Media</h1>
        <span class="settings-icon" onclick="openSettings()" title="Settings">&#9881;</span>
      </div>

      <div class="label-row">
        <label for="prompt">Prompt</label>
        <button class="save-btn" onclick="saveCurrentPrompt()" title="Save to history">&#128190;</button>
      </div>
      <textarea id="prompt" placeholder="Describe the image you want to generate..."></textarea>

      <div class="collapsible-header" onclick="toggleCollapsible('negativeSection')">
        <label style="margin:0;cursor:pointer">Negative Prompt</label>
        <button class="save-btn" onclick="event.stopPropagation(); saveCurrentNegPrompt()" title="Save to history">&#128190;</button>
        <span id="negativeSection-icon">+</span>
      </div>
      <div id="negativeSection" class="collapsible-content">
        <textarea id="negativePrompt" placeholder="What to avoid..." style="min-height:60px"></textarea>
        <div class="neg-history-section">
          <div class="collapsible-header small" onclick="event.stopPropagation(); toggleCollapsible('negHistorySection')">
            <label style="margin:0;cursor:pointer;font-size:0.8rem">History (<span id="negHistoryCount">0</span>)</label>
            <span id="negHistorySection-icon">+</span>
          </div>
          <div id="negHistorySection" class="collapsible-content">
            <div id="negHistoryList" class="history-list" style="max-height:120px"></div>
            <button class="btn-danger btn-small" onclick="clearNegHistory()" style="margin-top:6px;width:100%;font-size:0.75rem">Clear History</button>
          </div>
        </div>
      </div>

      <label for="aspectRatio">Aspect Ratio</label>
      <select id="aspectRatio">
        <option value="1:1">1:1 (Square)</option>
        <option value="4:5">4:5 (Portrait)</option>
        <option value="3:4">3:4 (Portrait)</option>
        <option value="2:3">2:3 (Portrait)</option>
        <option value="9:16">9:16 (Portrait)</option>
        <option value="5:4">5:4 (Landscape)</option>
        <option value="4:3" selected>4:3 (Landscape)</option>
        <option value="3:2">3:2 (Landscape)</option>
        <option value="16:9">16:9 (Landscape)</option>
        <option value="21:9">21:9 (Ultrawide)</option>
        <option value="custom">Custom Size</option>
      </select>

      <div id="customSize" style="display:none">
        <div class="row">
          <div>
            <label for="width">Width</label>
            <input type="number" id="width" value="1024" min="64" max="2048" step="64">
          </div>
          <div>
            <label for="height">Height</label>
            <input type="number" id="height" value="1024" min="64" max="2048" step="64">
          </div>
        </div>
      </div>

      <div id="baseSizeRow">
        <label for="baseSize">Base Size</label>
        <div class="range-row">
          <input type="range" id="baseSize" min="512" max="2048" step="64" value="1024">
          <span class="range-value" id="baseSizeValue">1024</span>
        </div>
      </div>

      <div class="collapsible-header" onclick="toggleCollapsible('advancedSection')">
        <label style="margin:0;cursor:pointer">Advanced Settings</label>
        <span id="advancedSection-icon">+</span>
      </div>
      <div id="advancedSection" class="collapsible-content">
        <label for="steps">Inference Steps</label>
        <div class="range-row">
          <input type="range" id="steps" min="1" max="50" value="9">
          <span class="range-value" id="stepsValue">9</span>
        </div>

        <label for="cfgScale">CFG Scale</label>
        <div class="range-row">
          <input type="range" id="cfgScale" min="0" max="20" step="0.5" value="0">
          <span class="range-value" id="cfgScaleValue">0</span>
        </div>

        <label for="seed">Seed (-1 for random)</label>
        <input type="number" id="seed" value="-1" min="-1">

        <label for="apiUrl">API URL</label>
        <input type="text" id="apiUrl" value="http://localhost:4201">

        <label for="model">Model</label>
        <input type="text" id="model" value="z-image-turbo">
      </div>

      <button id="generateBtn" class="btn-primary" onclick="generate()">Generate</button>

      <div id="status" class="status"></div>

      <div class="copy-section">
        <label>Copy Request</label>
        <div class="copy-buttons">
          <button class="btn-secondary btn-small" onclick="copyCurl()">cURL</button>
          <button class="btn-secondary btn-small" onclick="copyJson()">JSON</button>
          <button class="btn-secondary btn-small" onclick="copyPython()">Python</button>
        </div>
      </div>

      <div class="history-section">
        <div class="collapsible-header" onclick="toggleCollapsible('historySection')">
          <label style="margin:0;cursor:pointer">Prompt History (<span id="historyCount">0</span>)</label>
          <span id="historySection-icon">+</span>
        </div>
        <div id="historySection" class="collapsible-content">
          <div id="historyList" class="history-list"></div>
          <button class="btn-danger btn-small" onclick="clearHistory()" style="margin-top:8px;width:100%">Clear History</button>
        </div>
      </div>

      <!-- Simple Batch -->
      <div class="batch-section">
        <div class="collapsible-header" onclick="toggleCollapsible('simpleBatchSection')">
          <label style="margin:0;cursor:pointer">Simple Batch <span class="help-icon" onclick="event.stopPropagation(); showVariablesHelp()">?</span></label>
          <span id="simpleBatchSection-icon">+</span>
        </div>
        <div id="simpleBatchSection" class="collapsible-content">
          <p style="font-size:0.8rem;color:var(--text-dim);margin:0 0 8px">Generate X images with randomized [] variables</p>
          <div style="display:flex;gap:8px;align-items:center">
            <input type="number" id="simpleBatchCount" value="10" min="1" max="100" style="width:70px">
            <button id="simpleBatchBtn" class="btn-primary" onclick="generateSimpleBatch()" style="flex:1">Generate</button>
          </div>
          <button id="simpleBatchCancelBtn" class="btn-danger" onclick="cancelSimpleBatch()" style="width:100%;margin-top:8px;display:none">Cancel</button>
          <div id="simpleBatchProgress" class="batch-progress" style="display:none">
            <div class="batch-progress-bar">
              <div class="batch-progress-fill" id="simpleBatchProgressFill" style="width:0%"></div>
            </div>
            <div class="batch-progress-text" id="simpleBatchProgressText">0 / 0</div>
            <div class="batch-prompt" id="simpleBatchPrompt"></div>
          </div>
        </div>
      </div>

      <!-- JSON Batch -->
      <div class="batch-section">
        <div class="collapsible-header" onclick="toggleCollapsible('jsonBatchSection')">
          <label style="margin:0;cursor:pointer">JSON Batch <span class="help-icon" onclick="event.stopPropagation(); showVariablesHelp()">?</span></label>
          <button class="save-btn" onclick="event.stopPropagation(); saveCurrentJson()" title="Save to history">&#128190;</button>
          <span id="jsonBatchSection-icon">+</span>
        </div>
        <div id="jsonBatchSection" class="collapsible-content">
          <p style="font-size:0.8rem;color:var(--text-dim);margin:0 0 8px">Use {"{"}variables{"}"} from JSON data</p>
          <textarea id="batchJson" placeholder='[
  {"name": "Character1", "outfit": "Red dress"},
  {"name": "Character2", "outfit": "Blue suit"}
]'></textarea>
          <div id="jsonError" class="json-error"></div>
          <div id="jsonValid" class="json-valid"></div>
          <div style="display:flex;gap:8px;align-items:stretch;margin-top:8px">
            <button id="batchGenerateBtn" class="btn-primary" onclick="generateBatch()" style="flex:1">Generate Batch</button>
            <label style="display:flex;align-items:center;gap:4px;font-size:0.75rem;cursor:pointer;white-space:nowrap;padding:0 4px">
              <input type="checkbox" id="batchRandomize" onchange="saveBatchRandomize()" style="margin:0">
              Shuffle
            </label>
          </div>
          <button id="batchCancelBtn" class="btn-danger" onclick="cancelBatch()" style="width:100%;margin-top:8px;display:none">Cancel</button>
          <div id="batchProgress" class="batch-progress" style="display:none">
            <div class="batch-progress-bar">
              <div class="batch-progress-fill" id="batchProgressFill" style="width:0%"></div>
            </div>
            <div class="batch-progress-text" id="batchProgressText">0 / 0</div>
            <div class="batch-names" id="batchNames"></div>
            <div class="batch-prompt" id="batchPrompt"></div>
          </div>
          <div class="collapsible-header small" onclick="event.stopPropagation(); toggleCollapsible('jsonHistorySection')" style="margin-top:12px">
            <label style="margin:0;cursor:pointer;font-size:0.8rem">JSON History (<span id="jsonHistoryCount">0</span>)</label>
            <span id="jsonHistorySection-icon">+</span>
          </div>
          <div id="jsonHistorySection" class="collapsible-content">
            <div id="jsonHistoryList" class="history-list" style="max-height:150px"></div>
            <button class="btn-danger btn-small" onclick="clearJsonHistory()" style="margin-top:6px;width:100%;font-size:0.75rem">Clear History</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Preview & Gallery -->
    <div>
      <div class="preview-container" id="previewContainer">
        <div class="preview-placeholder">
          <p>Generated image will appear here</p>
        </div>
      </div>

      <div class="panel">
        <div class="gallery-header">
          <h2>Gallery (<span id="galleryCount">0</span>)</h2>
          <div>
            <button class="btn-secondary btn-small" onclick="downloadZip()" id="downloadZipBtn">Download ZIP</button>
            <button class="btn-secondary btn-small" onclick="selectAll()" id="selectAllBtn">Select All</button>
            <button class="btn-danger btn-small" onclick="deleteSelected()" id="deleteSelectedBtn" style="display:none">Delete Selected</button>
            <button class="btn-danger btn-small" onclick="clearGallery()">Clear All</button>
          </div>
        </div>
        <div id="galleryFolders" class="gallery-folders"></div>
        <div id="gallery" class="gallery-grid"></div>
        <div id="galleryPagination"></div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal" onclick="closeModal(event)">
    <span class="modal-close" onclick="closeModal()">&times;</span>
    <span class="modal-counter" id="modalCounter">1 / 1</span>

    <div class="modal-main" onclick="event.stopPropagation()">
      <span class="modal-nav prev" id="modalPrev" onclick="navigateModal(-1)">&lsaquo;</span>
      <img id="modalImg" src="">
      <span class="modal-nav next" id="modalNext" onclick="navigateModal(1)">&rsaquo;</span>
      <div class="modal-name-label" id="modalNameLabel" style="display: none;"></div>
    </div>

    <div class="thumbnail-strip" id="thumbnailStrip" onclick="event.stopPropagation()"></div>

    <div class="modal-prompt" id="modalPrompt" onclick="event.stopPropagation()"></div>

    <div class="modal-info" onclick="event.stopPropagation()">
      <pre id="modalInfo"></pre>
      <div class="modal-actions">
        <button class="btn-secondary btn-small" onclick="downloadImage(currentModalId)">Download</button>
        <button class="btn-secondary btn-small" onclick="reuseSettings(currentModalId)">Reuse Settings</button>
        <button class="btn-danger btn-small" onclick="deleteFromModal()">Delete</button>
      </div>
    </div>
  </div>

  <!-- Toast -->
  <div class="toast" id="toast"></div>

  <!-- Help Modal -->
  <div class="help-modal" id="helpModal" onclick="closeHelpModal(event)">
    <div class="help-content" onclick="event.stopPropagation()">
      <span class="help-close" onclick="closeHelpModal()">&times;</span>
      <h3>Batch Mode Variables</h3>

      <h4>JSON Variables <code>{variable}</code></h4>
      <p>Use values from your JSON data:</p>
      <pre>Prompt: "{name} wearing {outfit}"
JSON: [{"name": "Alice", "outfit": "red dress"}]
Result: "Alice wearing red dress"</pre>

      <h4>Relative References <code>{variable+N}</code></h4>
      <p>Reference other items in the batch (circular):</p>
      <pre>Prompt: "{name} with {name+1}"
JSON: [{"name": "Alice"}, {"name": "Bob"}, {"name": "Charlie"}]
Results:
  1: "Alice with Bob"
  2: "Bob with Charlie"
  3: "Charlie with Alice" (wraps around)</pre>
      <p><code>{name-1}</code> gets previous item, <code>{name+2}</code> skips one, etc.</p>

      <h4>Random Built-ins <code>[variable]</code></h4>
      <p>Random values picked fresh for each image:</p>
      <table>
        <tr><td><code>[location]</code></td><td>bedroom, beach, forest, city street, etc.</td></tr>
        <tr><td><code>[time]</code></td><td>at dawn, at sunset, at night, etc.</td></tr>
        <tr><td><code>[weather]</code></td><td>sunny, rainy, foggy, stormy, etc.</td></tr>
        <tr><td><code>[mood]</code></td><td>peaceful, dramatic, romantic, etc.</td></tr>
        <tr><td><code>[lighting]</code></td><td>soft natural light, neon lights, candlelight, etc.</td></tr>
        <tr><td><code>[color]</code></td><td>red, emerald, navy, gold, lavender, etc.</td></tr>
        <tr><td><code>[size]</code></td><td>small, medium, large</td></tr>
        <tr><td><code>[pose]</code></td><td>standing, sitting, dancing, kneeling, etc.</td></tr>
        <tr><td><code>[object]</code></td><td>chair, bed, table, stairs, swing, etc.</td></tr>
        <tr><td><code>[race]</code></td><td>caucasian, african, asian, latino, etc.</td></tr>
        <tr><td><code>[expression]</code></td><td>smiling, serious, laughing, seductive, etc.</td></tr>
        <tr><td><code>[hairstyle]</code></td><td>with long wavy hair, with a ponytail, with bangs, etc.</td></tr>
        <tr><td><code>[haircolor]</code></td><td>blonde, brunette, red, black, pink, etc.</td></tr>
        <tr><td><code>[hairstyle-color]</code></td><td>combines both: with long wavy blonde hair, with a red ponytail</td></tr>
      </table>

      <h4>Number Ranges <code>[N-M]</code></h4>
      <p>Random integer between N and M (inclusive):</p>
      <pre>"[race] woman, [20-35] years old, [expression]"
→ "asian woman, 27 years old, smiling"</pre>

      <h4>Examples</h4>
      <pre>"{name} [hairstyle-color], [pose] in [location], [expression]"
→ "Alice with a blonde ponytail, sitting in coffee shop, laughing"

"[race] woman [hairstyle-color], [expression], wearing [color] dress"
→ "nordic woman with long wavy red hair, seductive, wearing blue dress"

"{name} [hairstyle-color], [pose] on [object], [mood] [lighting]"
→ "Alice with a messy brunette bun, leaning on railing, romantic golden hour glow"</pre>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="settings-modal" id="settingsModal" onclick="closeSettings(event)">
    <div class="settings-content" onclick="event.stopPropagation()">
      <span class="help-close" onclick="closeSettings()">&times;</span>
      <h3>Settings</h3>
      <div class="settings-row">
        <label>Batch Debounce</label>
        <select id="settingDebounce" onchange="saveSettings()">
          <option value="500">500ms</option>
          <option value="1000" selected>1000ms</option>
          <option value="2000">2000ms</option>
          <option value="3000">3000ms</option>
          <option value="5000">5000ms</option>
          <option value="10000">10000ms</option>
        </select>
      </div>
    </div>
  </div>

  <script>
    // IndexedDB for storing images
    const DB_NAME = 'sillyMediaGallery';
    const DB_VERSION = 2; // Bumped for thumbnail support
    const STORE_NAME = 'images';
    const SETTINGS_KEY = 'sillyMediaSettings';
    const HISTORY_KEY = 'sillyMediaHistory';
    const NEG_HISTORY_KEY = 'sillyMediaNegHistory';
    const JSON_HISTORY_KEY = 'sillyMediaJsonHistory';
    const MAX_HISTORY = 50;
    const THUMB_SIZE = 200; // Thumbnail max dimension
    const PAGE_SIZE = 24; // Images per page
    let db;
    let selectedItems = new Set();
    let currentModalId = null;
    let galleryImages = []; // Cache for carousel navigation
    let currentImageIndex = 0;
    let currentFolder = 'all'; // Current gallery folder filter
    let batchCancelled = false; // Flag to cancel batch generation
    let simpleBatchCancelled = false; // Flag to cancel simple batch
    let currentPage = 0; // Current gallery page
    let galleryObserver = null; // IntersectionObserver for lazy loading

    // Initialize
    async function init() {
      db = await openDB();
      loadSavedSettings();
      loadHistory();
      loadNegHistory();
      loadJsonHistory();
      loadBatchRandomize();
      loadAppSettings();
      await loadGallery();
      setupEventListeners();
    }

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          }
          // Migration: generate thumbnails for existing images will happen lazily
        };
      });
    }

    // Generate thumbnail from full image data URL
    function generateThumbnail(dataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let w = img.width, h = img.height;
          if (w > h) {
            if (w > THUMB_SIZE) { h = h * THUMB_SIZE / w; w = THUMB_SIZE; }
          } else {
            if (h > THUMB_SIZE) { w = w * THUMB_SIZE / h; h = THUMB_SIZE; }
          }
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);
          resolve(canvas.toDataURL('image/jpeg', 0.7));
        };
        img.onerror = () => resolve(dataUrl); // Fallback to full image
        img.src = dataUrl;
      });
    }

    function dbTransaction(mode) {
      return db.transaction(STORE_NAME, mode).objectStore(STORE_NAME);
    }

    async function saveImage(blob, settings, folder = null) {
      const reader = new FileReader();
      const dataUrl = await new Promise((resolve) => {
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });

      // Generate thumbnail
      const thumbnail = await generateThumbnail(dataUrl);

      return new Promise((resolve, reject) => {
        const store = dbTransaction('readwrite');
        const item = {
          data: dataUrl,
          thumbnail,
          settings,
          timestamp: Date.now(),
          folder: folder
        };
        const request = store.add(item);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function getAllImages() {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readonly');
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function deleteImage(id) {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readwrite');
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async function getImage(id) {
      return new Promise((resolve, reject) => {
        const store = dbTransaction('readonly');
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Settings persistence
    function saveSettings() {
      const settings = {
        prompt: document.getElementById('prompt').value,
        aspectRatio: document.getElementById('aspectRatio').value,
        baseSize: document.getElementById('baseSize').value,
        width: document.getElementById('width').value,
        height: document.getElementById('height').value,
        steps: document.getElementById('steps').value,
        cfgScale: document.getElementById('cfgScale').value,
        seed: document.getElementById('seed').value,
        apiUrl: document.getElementById('apiUrl').value,
        model: document.getElementById('model').value,
        negativePrompt: document.getElementById('negativePrompt').value,
        batchJson: document.getElementById('batchJson').value
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
    }

    function loadSavedSettings() {
      const saved = localStorage.getItem(SETTINGS_KEY);
      if (!saved) return;

      try {
        const s = JSON.parse(saved);
        if (s.prompt) document.getElementById('prompt').value = s.prompt;
        if (s.aspectRatio) {
          document.getElementById('aspectRatio').value = s.aspectRatio;
          const custom = s.aspectRatio === 'custom';
          document.getElementById('customSize').style.display = custom ? 'block' : 'none';
          document.getElementById('baseSizeRow').style.display = custom ? 'none' : 'block';
        }
        if (s.baseSize) {
          document.getElementById('baseSize').value = s.baseSize;
          document.getElementById('baseSizeValue').textContent = s.baseSize;
        }
        if (s.width) document.getElementById('width').value = s.width;
        if (s.height) document.getElementById('height').value = s.height;
        if (s.steps) {
          document.getElementById('steps').value = s.steps;
          document.getElementById('stepsValue').textContent = s.steps;
        }
        if (s.cfgScale !== undefined) {
          document.getElementById('cfgScale').value = s.cfgScale;
          document.getElementById('cfgScaleValue').textContent = s.cfgScale;
        }
        if (s.seed) document.getElementById('seed').value = s.seed;
        if (s.apiUrl) document.getElementById('apiUrl').value = s.apiUrl;
        if (s.model) document.getElementById('model').value = s.model;
        if (s.negativePrompt) document.getElementById('negativePrompt').value = s.negativePrompt;
        if (s.batchJson) {
          document.getElementById('batchJson').value = s.batchJson;
          validateBatchJson(); // Validate on load to show status
        }
      } catch (e) {
        console.error('Failed to load settings:', e);
      }
    }

    // Prompt history
    function getHistory() {
      try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
      } catch {
        return [];
      }
    }

    function addToHistory(promptText) {
      if (!promptText?.trim()) return;
      const history = getHistory();
      // Don't add duplicates (same prompt)
      const existingIndex = history.findIndex(h => h.prompt === promptText);
      if (existingIndex !== -1) {
        // Keep favorite status if already exists
        return;
      }
      // Add to front
      history.unshift({
        prompt: promptText,
        favorite: false,
        timestamp: Date.now()
      });
      // Limit size (don't remove favorites)
      while (history.length > MAX_HISTORY) {
        const lastNonFav = history.findLastIndex(h => !h.favorite);
        if (lastNonFav > -1) history.splice(lastNonFav, 1);
        else break;
      }
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      loadHistory();
      showToast('Prompt saved');
    }

    function saveCurrentPrompt() {
      const prompt = document.getElementById('prompt').value.trim();
      if (!prompt) {
        showToast('No prompt to save');
        return;
      }
      addToHistory(prompt);
    }

    function toggleFavoriteHistory(index) {
      const history = getHistory();
      if (history[index]) {
        history[index].favorite = !history[index].favorite;
        localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        loadHistory();
      }
    }

    function loadHistory() {
      const history = getHistory();
      const container = document.getElementById('historyList');
      document.getElementById('historyCount').textContent = history.length;

      if (history.length === 0) {
        container.innerHTML = '<div class="empty-history">No prompt history yet</div>';
        return;
      }

      // Sort: favorites first, then by timestamp
      const sorted = [...history].map((h, i) => ({...h, origIndex: i}))
        .sort((a, b) => {
          if (a.favorite && !b.favorite) return -1;
          if (!a.favorite && b.favorite) return 1;
          return b.timestamp - a.timestamp;
        });

      container.innerHTML = sorted.map(h => `
        <div class="history-item" onclick="applyHistoryItem(${h.origIndex})">
          <button class="fav-btn ${h.favorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavoriteHistory(${h.origIndex})" title="${h.favorite ? 'Unpin' : 'Pin'}">&#9733;</button>
          <span class="prompt-text">${escapeHtml(h.prompt)}</span>
          <button class="btn-danger btn-small delete-btn" onclick="event.stopPropagation(); deleteHistoryItem(${h.origIndex})">x</button>
        </div>
      `).join('');
    }

    function applyHistoryItem(index) {
      const history = getHistory();
      const h = history[index];
      if (!h) return;

      document.getElementById('prompt').value = h.prompt || '';
      saveSettings();
      showToast('Prompt loaded');
    }

    function deleteHistoryItem(index) {
      const history = getHistory();
      history.splice(index, 1);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      loadHistory();
      showToast('Removed from history');
    }

    function clearHistory() {
      if (!confirm('Clear all prompt history?')) return;
      localStorage.removeItem(HISTORY_KEY);
      loadHistory();
      showToast('History cleared');
    }

    // Negative prompt history
    function getNegHistory() {
      try {
        return JSON.parse(localStorage.getItem(NEG_HISTORY_KEY) || '[]');
      } catch {
        return [];
      }
    }

    function addToNegHistory(negPrompt) {
      if (!negPrompt || !negPrompt.trim()) return;
      const history = getNegHistory();
      // Don't add duplicates
      const existingIndex = history.findIndex(h => h.prompt === negPrompt);
      if (existingIndex !== -1) {
        return;
      }
      // Add to front
      history.unshift({
        prompt: negPrompt,
        favorite: false,
        timestamp: Date.now()
      });
      // Limit size (don't remove favorites)
      while (history.length > MAX_HISTORY) {
        const lastNonFav = history.findLastIndex(h => !h.favorite);
        if (lastNonFav > -1) history.splice(lastNonFav, 1);
        else break;
      }
      localStorage.setItem(NEG_HISTORY_KEY, JSON.stringify(history));
      loadNegHistory();
      showToast('Negative prompt saved');
    }

    function saveCurrentNegPrompt() {
      const prompt = document.getElementById('negativePrompt').value.trim();
      if (!prompt) {
        showToast('No negative prompt to save');
        return;
      }
      addToNegHistory(prompt);
    }

    function toggleFavoriteNegHistory(index) {
      const history = getNegHistory();
      if (history[index]) {
        history[index].favorite = !history[index].favorite;
        localStorage.setItem(NEG_HISTORY_KEY, JSON.stringify(history));
        loadNegHistory();
      }
    }

    function loadNegHistory() {
      const history = getNegHistory();
      const container = document.getElementById('negHistoryList');
      document.getElementById('negHistoryCount').textContent = history.length;

      if (history.length === 0) {
        container.innerHTML = '<div class="empty-history">No negative prompt history yet</div>';
        return;
      }

      // Sort: favorites first, then by timestamp
      const sorted = [...history].map((h, i) => ({...h, origIndex: i}))
        .sort((a, b) => {
          if (a.favorite && !b.favorite) return -1;
          if (!a.favorite && b.favorite) return 1;
          return b.timestamp - a.timestamp;
        });

      container.innerHTML = sorted.map(h => `
        <div class="history-item" onclick="applyNegHistoryItem(${h.origIndex})">
          <button class="fav-btn ${h.favorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavoriteNegHistory(${h.origIndex})" title="${h.favorite ? 'Unpin' : 'Pin'}">&#9733;</button>
          <span class="prompt-text">${escapeHtml(h.prompt)}</span>
          <button class="btn-danger btn-small delete-btn" onclick="event.stopPropagation(); deleteNegHistoryItem(${h.origIndex})">x</button>
        </div>
      `).join('');
    }

    function applyNegHistoryItem(index) {
      const history = getNegHistory();
      const h = history[index];
      if (!h) return;
      document.getElementById('negativePrompt').value = h.prompt;
      saveSettings();
      showToast('Negative prompt loaded');
    }

    function deleteNegHistoryItem(index) {
      const history = getNegHistory();
      history.splice(index, 1);
      localStorage.setItem(NEG_HISTORY_KEY, JSON.stringify(history));
      loadNegHistory();
      showToast('Removed from history');
    }

    function clearNegHistory() {
      if (!confirm('Clear all negative prompt history?')) return;
      localStorage.removeItem(NEG_HISTORY_KEY);
      loadNegHistory();
      showToast('Negative history cleared');
    }

    // JSON History
    function getJsonHistory() {
      const raw = JSON.parse(localStorage.getItem(JSON_HISTORY_KEY) || '[]');
      // Migrate old format (array of strings) to new format (array of objects)
      return raw.map(item => typeof item === 'string' ? { json: item, favorite: false, timestamp: Date.now() } : item);
    }

    function addToJsonHistory(jsonText) {
      if (!jsonText?.trim()) return;
      const history = getJsonHistory();
      // Don't add duplicates
      const existingIndex = history.findIndex(h => h.json === jsonText);
      if (existingIndex !== -1) {
        return;
      }
      // Add to front
      history.unshift({
        json: jsonText,
        favorite: false,
        timestamp: Date.now()
      });
      // Limit size (don't remove favorites)
      while (history.length > MAX_HISTORY) {
        const lastNonFav = history.findLastIndex(h => !h.favorite);
        if (lastNonFav > -1) history.splice(lastNonFav, 1);
        else break;
      }
      localStorage.setItem(JSON_HISTORY_KEY, JSON.stringify(history));
      loadJsonHistory();
      showToast('JSON saved');
    }

    function saveCurrentJson() {
      const json = document.getElementById('batchJson').value.trim();
      if (!json) {
        showToast('No JSON to save');
        return;
      }
      // Validate first
      try {
        JSON.parse(json);
      } catch (e) {
        showToast('Invalid JSON - fix before saving');
        return;
      }
      addToJsonHistory(json);
    }

    function toggleFavoriteJsonHistory(index) {
      const history = getJsonHistory();
      if (history[index]) {
        history[index].favorite = !history[index].favorite;
        localStorage.setItem(JSON_HISTORY_KEY, JSON.stringify(history));
        loadJsonHistory();
      }
    }

    function loadJsonHistory() {
      const history = getJsonHistory();
      const list = document.getElementById('jsonHistoryList');
      const count = document.getElementById('jsonHistoryCount');
      if (!list) return;

      count.textContent = history.length;

      if (history.length === 0) {
        list.innerHTML = '<div class="empty-history">No JSON history yet</div>';
        return;
      }

      // Sort: favorites first, then by timestamp
      const sorted = [...history].map((h, i) => ({...h, origIndex: i}))
        .sort((a, b) => {
          if (a.favorite && !b.favorite) return -1;
          if (!a.favorite && b.favorite) return 1;
          return (b.timestamp || 0) - (a.timestamp || 0);
        });

      list.innerHTML = sorted.map(h => {
        // Parse to show summary
        let summary = '';
        try {
          const data = JSON.parse(h.json);
          const keys = [...new Set(data.flatMap(item => Object.keys(item)))];
          summary = `${data.length} items: ${keys.join(', ')}`;
        } catch (e) {
          summary = h.json.substring(0, 50) + '...';
        }
        return `
          <div class="history-item" onclick="loadJsonHistoryItem(${h.origIndex})">
            <button class="fav-btn ${h.favorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavoriteJsonHistory(${h.origIndex})" title="${h.favorite ? 'Unpin' : 'Pin'}">&#9733;</button>
            <span class="prompt-text">${escapeHtml(summary)}</span>
            <button class="btn-danger btn-small delete-btn" onclick="event.stopPropagation(); deleteJsonHistoryItem(${h.origIndex})">x</button>
          </div>
        `;
      }).join('');
    }

    function loadJsonHistoryItem(index) {
      const history = getJsonHistory();
      if (history[index]) {
        document.getElementById('batchJson').value = history[index].json;
        validateBatchJson();
        showToast('JSON loaded from history');
      }
    }

    function deleteJsonHistoryItem(index) {
      const history = getJsonHistory();
      history.splice(index, 1);
      localStorage.setItem(JSON_HISTORY_KEY, JSON.stringify(history));
      loadJsonHistory();
      showToast('Removed from history');
    }

    function clearJsonHistory() {
      if (!confirm('Clear all JSON history?')) return;
      localStorage.removeItem(JSON_HISTORY_KEY);
      loadJsonHistory();
      showToast('JSON history cleared');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // UI Functions
    function setupEventListeners() {
      // Range sliders with auto-save
      document.getElementById('baseSize').oninput = (e) => {
        document.getElementById('baseSizeValue').textContent = e.target.value;
        saveSettings();
      };
      document.getElementById('steps').oninput = (e) => {
        document.getElementById('stepsValue').textContent = e.target.value;
        saveSettings();
      };
      document.getElementById('cfgScale').oninput = (e) => {
        document.getElementById('cfgScaleValue').textContent = e.target.value;
        saveSettings();
      };

      // Aspect ratio change with auto-save
      document.getElementById('aspectRatio').onchange = (e) => {
        const custom = e.target.value === 'custom';
        document.getElementById('customSize').style.display = custom ? 'block' : 'none';
        document.getElementById('baseSizeRow').style.display = custom ? 'none' : 'block';
        saveSettings();
      };

      // Other inputs auto-save
      ['prompt', 'width', 'height', 'seed', 'apiUrl', 'model', 'negativePrompt'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('input', saveSettings);
        el.addEventListener('change', saveSettings);
      });

      // Batch JSON validation and save on input
      document.getElementById('batchJson').addEventListener('input', () => {
        validateBatchJson();
        saveSettings();
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        const modalOpen = document.getElementById('modal').classList.contains('open');

        if (e.key === 'Escape') closeModal();
        if (e.key === 'Enter' && e.ctrlKey && !modalOpen) generate();

        // Carousel navigation
        if (modalOpen) {
          if (e.key === 'ArrowLeft') navigateModal(-1);
          if (e.key === 'ArrowRight') navigateModal(1);
          if (e.key === 'Home') goToImage(0);
          if (e.key === 'End') goToImage(galleryImages.length - 1);
        }
      });
    }

    function toggleCollapsible(id) {
      const content = document.getElementById(id);
      const icon = document.getElementById(id + '-icon');
      const isOpen = content.classList.toggle('open');
      icon.textContent = isOpen ? '−' : '+';
    }

    function getSettings() {
      const aspectRatio = document.getElementById('aspectRatio').value;
      const settings = {
        prompt: document.getElementById('prompt').value,
        negative_prompt: document.getElementById('negativePrompt').value || undefined,
        num_inference_steps: parseInt(document.getElementById('steps').value),
        cfg_scale: parseFloat(document.getElementById('cfgScale').value),
        seed: parseInt(document.getElementById('seed').value)
      };

      if (aspectRatio === 'custom') {
        settings.width = parseInt(document.getElementById('width').value);
        settings.height = parseInt(document.getElementById('height').value);
      } else {
        settings.aspect_ratio = aspectRatio;
        settings.base_size = parseInt(document.getElementById('baseSize').value);
      }

      // Clean up
      if (settings.seed === -1) delete settings.seed;
      if (!settings.negative_prompt) delete settings.negative_prompt;

      return settings;
    }

    function getApiUrl() {
      return document.getElementById('apiUrl').value;
    }

    function getModel() {
      return document.getElementById('model').value;
    }

    async function generate() {
      const promptTemplate = document.getElementById('prompt').value.trim();
      if (!promptTemplate) {
        showStatus('Please enter a prompt', 'error');
        return;
      }

      const btn = document.getElementById('generateBtn');
      btn.disabled = true;
      btn.textContent = 'Generating...';
      showStatus('Generating image...', 'loading');

      // Interpolate random variables [location], [time], etc. for single generation
      const prompt = interpolatePrompt(promptTemplate, {});
      const negativeTemplate = document.getElementById('negativePrompt').value;
      const negativePrompt = interpolatePrompt(negativeTemplate, {});

      const settings = getSettings();
      settings.prompt = prompt;
      if (negativePrompt && negativePrompt.trim()) {
        settings.negative_prompt = negativePrompt;
      }
      const url = `${getApiUrl()}/generate/${getModel()}`;

      try {
        const start = Date.now();
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(settings)
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.detail || error.error || 'Generation failed');
        }

        const blob = await response.blob();
        const elapsed = ((Date.now() - start) / 1000).toFixed(1);

        // Save to gallery
        const id = await saveImage(blob, settings);
        await loadGallery();

        // Show preview with prompt
        const imgUrl = URL.createObjectURL(blob);
        showPreview(imgUrl, id, settings.prompt);

        showStatus(`Generated in ${elapsed}s`, 'success');
      } catch (error) {
        showStatus(error.message, 'error');
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate';
      }
    }

    function showPreview(url, id, prompt = null, template = null, variables = null, batchData = null, batchIndex = 0) {
      const container = document.getElementById('previewContainer');
      let promptHtml = '';

      if (prompt) {
        // Use the already-resolved prompt with highlighting (don't regenerate random values!)
        // Always call highlightStoredPrompt to highlight builtin [] variables even without JSON variables
        promptHtml = `<div class="preview-prompt">${highlightStoredPrompt(prompt, variables || {}, batchData, batchIndex)}</div>`;
      }

      container.innerHTML = `
        <div class="debounce-bar" id="debounceBar" style="display:none"><div class="debounce-bar-fill" id="debounceBarFill"></div></div>
        <img src="${url}" alt="Generated image">
        ${promptHtml}
        <div class="preview-actions">
          <button class="btn-secondary btn-small" onclick="downloadImage(${id})">Download</button>
        </div>
      `;
    }

    function highlightPromptVariables(template, variables, batchData = null, currentIndex = 0) {
      let result = escapeHtml(template);

      // Highlight [builtin] variables (random) - green
      result = result.replace(/\[(\w+)\]/g, (match, key) => {
        const value = getRandomBuiltin(key);
        if (value !== null) {
          return `<span class="var-builtin">${escapeHtml(value)}</span>`;
        }
        return match;
      });

      // Highlight {variable+N} or {variable-N} references - purple
      result = result.replace(/\{(\w+)([+-]\d+)\}/g, (match, key, offset) => {
        if (batchData) {
          const offsetNum = parseInt(offset, 10);
          const total = batchData.length;
          const targetIndex = ((currentIndex + offsetNum) % total + total) % total;
          const targetVars = batchData[targetIndex];
          if (targetVars?.hasOwnProperty(key)) {
            return `<span class="var-ref">${escapeHtml(targetVars[key])}</span>`;
          }
        }
        return match;
      });

      // Highlight {variable} - pink/accent
      result = result.replace(/\{(\w+)\}/g, (match, key) => {
        if (variables.hasOwnProperty(key)) {
          return `<span class="var-json">${escapeHtml(variables[key])}</span>`;
        }
        return match;
      });

      return result;
    }

    // Highlight stored prompt by finding variable values within the already-resolved prompt
    function highlightStoredPrompt(prompt, variables, batchData = null, batchIndex = 0) {
      let result = escapeHtml(prompt);

      // Collect all variable values to highlight (from current item and referenced items)
      const allValues = new Set();

      // Add current variables
      for (const value of Object.values(variables)) {
        if (value && typeof value === 'string') {
          allValues.add(value);
        }
      }

      // Add values from all batch items (for relative references like {name+1})
      if (batchData) {
        for (const item of batchData) {
          for (const value of Object.values(item)) {
            if (value && typeof value === 'string') {
              allValues.add(value);
            }
          }
        }
      }

      // Highlight each variable value found in the prompt (pink for JSON vars)
      for (const value of allValues) {
        const escaped = escapeHtml(value).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`(?<![\\w-])${escaped}(?![\\w-])`, 'g');
        result = result.replace(regex, `<span class="var-json">${escapeHtml(value)}</span>`);
      }

      // Try to identify builtin values (location, time, etc.) - they're harder to detect
      // but we can highlight known patterns
      for (const [category, values] of Object.entries(BUILTIN_VARS)) {
        for (const value of values) {
          const escaped = escapeHtml(value).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const regex = new RegExp(`(?<![\\w-])${escaped}(?![\\w-])`, 'gi');
          result = result.replace(regex, `<span class="var-builtin">${escapeHtml(value)}</span>`);
        }
      }

      return result;
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;
    }

    // Cache for filtered/sorted images
    let filteredImages = [];

    async function loadGallery(resetPage = true) {
      const allImages = await getAllImages();
      const gallery = document.getElementById('gallery');
      const foldersEl = document.getElementById('galleryFolders');

      if (resetPage) currentPage = 0;

      // Get unique folders
      const folders = new Set(['all']);
      allImages.forEach(img => {
        if (img.folder) folders.add(img.folder);
      });

      // Build folder tabs
      if (folders.size > 1) {
        const folderCounts = {};
        folderCounts['all'] = allImages.length;
        allImages.forEach(img => {
          const f = img.folder || 'all';
          folderCounts[f] = (folderCounts[f] || 0) + 1;
        });

        foldersEl.innerHTML = Array.from(folders).map(f => `
          <div class="folder-tab ${currentFolder === f ? 'active' : ''}" onclick="setFolder('${escapeHtml(f)}')">
            ${f === 'all' ? 'All' : escapeHtml(f)}<span class="count">(${folderCounts[f] || 0})</span>
          </div>
        `).join('');
      } else {
        foldersEl.innerHTML = '';
      }

      // Filter images by current folder
      filteredImages = allImages;
      if (currentFolder !== 'all') {
        filteredImages = allImages.filter(img => img.folder === currentFolder);
      }

      // Sort by newest first
      filteredImages.sort((a, b) => b.timestamp - a.timestamp);

      const totalImages = filteredImages.length;
      const totalPages = Math.ceil(totalImages / PAGE_SIZE);
      document.getElementById('galleryCount').textContent = totalImages;

      if (totalImages === 0) {
        gallery.innerHTML = '<div class="empty-gallery">No images yet. Generate some!</div>';
        document.getElementById('galleryPagination').innerHTML = '';
        return;
      }

      // Get current page images
      const start = currentPage * PAGE_SIZE;
      const pageImages = filteredImages.slice(start, start + PAGE_SIZE);

      gallery.innerHTML = pageImages.map(img => {
        const nameLabel = img.settings?._variables?.name;
        const thumbSrc = img.thumbnail || img.data; // Fallback for old images
        return `
        <div class="gallery-item ${selectedItems.has(img.id) ? 'selected' : ''}"
             data-id="${img.id}"
             onclick="toggleSelect(event, ${img.id})"
             ondblclick="openModal(${img.id})">
          <img data-src="${thumbSrc}" alt="Generated image" class="lazy-img">
          <div class="checkbox">${selectedItems.has(img.id) ? '✓' : ''}</div>
          ${nameLabel ? `<div class="name-label">${escapeHtml(nameLabel)}</div>` : ''}
          <div class="overlay">
            <button class="btn-secondary btn-small" onclick="event.stopPropagation(); openModal(${img.id})">View</button>
            <button class="btn-secondary btn-small" onclick="event.stopPropagation(); downloadImage(${img.id})">Save</button>
          </div>
        </div>
      `}).join('');

      // Build pagination
      renderPagination(totalPages);

      // Setup lazy loading
      setupLazyLoading();

      updateDeleteButton();
    }

    function renderPagination(totalPages) {
      const paginationEl = document.getElementById('galleryPagination');
      if (totalPages <= 1) {
        paginationEl.innerHTML = '';
        return;
      }

      let html = '<div class="pagination">';

      // Previous button
      html += `<button class="btn-secondary btn-small" ${currentPage === 0 ? 'disabled' : ''} onclick="goToPage(${currentPage - 1})">←</button>`;

      // Page numbers (show max 7 pages with ellipsis)
      const maxVisible = 7;
      let startPage = Math.max(0, currentPage - Math.floor(maxVisible / 2));
      let endPage = Math.min(totalPages - 1, startPage + maxVisible - 1);
      if (endPage - startPage < maxVisible - 1) {
        startPage = Math.max(0, endPage - maxVisible + 1);
      }

      if (startPage > 0) {
        html += `<button class="btn-secondary btn-small" onclick="goToPage(0)">1</button>`;
        if (startPage > 1) html += `<span class="pagination-ellipsis">...</span>`;
      }

      for (let i = startPage; i <= endPage; i++) {
        html += `<button class="btn-secondary btn-small ${i === currentPage ? 'active' : ''}" onclick="goToPage(${i})">${i + 1}</button>`;
      }

      if (endPage < totalPages - 1) {
        if (endPage < totalPages - 2) html += `<span class="pagination-ellipsis">...</span>`;
        html += `<button class="btn-secondary btn-small" onclick="goToPage(${totalPages - 1})">${totalPages}</button>`;
      }

      // Next button
      html += `<button class="btn-secondary btn-small" ${currentPage === totalPages - 1 ? 'disabled' : ''} onclick="goToPage(${currentPage + 1})">→</button>`;

      html += '</div>';
      paginationEl.innerHTML = html;
    }

    function goToPage(page) {
      currentPage = page;
      loadGallery(false);
      document.getElementById('gallery').scrollIntoView({ behavior: 'smooth' });
    }

    function setupLazyLoading() {
      // Disconnect old observer
      if (galleryObserver) galleryObserver.disconnect();

      galleryObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            if (img.dataset.src) {
              img.src = img.dataset.src;
              img.removeAttribute('data-src');
              img.classList.remove('lazy-img');
              galleryObserver.unobserve(img);
            }
          }
        });
      }, { rootMargin: '100px' });

      document.querySelectorAll('.lazy-img').forEach(img => {
        galleryObserver.observe(img);
      });
    }

    function setFolder(folder) {
      currentFolder = folder;
      currentPage = 0;
      selectedItems.clear();
      loadGallery();
    }

    function toggleSelect(event, id) {
      if (event.detail === 2) return; // Ignore double clicks

      if (selectedItems.has(id)) {
        selectedItems.delete(id);
      } else {
        selectedItems.add(id);
      }
      loadGallery();
    }

    function selectAll() {
      const gallery = document.getElementById('gallery');
      const items = gallery.querySelectorAll('.gallery-item');

      if (selectedItems.size === items.length) {
        selectedItems.clear();
      } else {
        items.forEach(item => selectedItems.add(parseInt(item.dataset.id)));
      }
      loadGallery();
    }

    function updateDeleteButton() {
      const btn = document.getElementById('deleteSelectedBtn');
      btn.style.display = selectedItems.size > 0 ? 'inline-block' : 'none';
      btn.textContent = `Delete (${selectedItems.size})`;
    }

    async function deleteSelected() {
      if (selectedItems.size === 0) return;
      if (!confirm(`Delete ${selectedItems.size} image(s)?`)) return;

      for (const id of selectedItems) {
        await deleteImage(id);
      }
      selectedItems.clear();
      await loadGallery();
      showToast('Images deleted');
    }

    async function clearGallery() {
      const images = await getAllImages();
      if (images.length === 0) return;
      if (!confirm(`Delete all ${images.length} image(s)?`)) return;

      for (const img of images) {
        await deleteImage(img.id);
      }
      selectedItems.clear();
      await loadGallery();
      showToast('Gallery cleared');
    }

    async function openModal(id) {
      // Get all images for carousel, filtered by current folder
      let allImages = await getAllImages();
      allImages.sort((a, b) => b.timestamp - a.timestamp);

      // Filter by current folder
      if (currentFolder !== 'all') {
        galleryImages = allImages.filter(img => img.folder === currentFolder);
      } else {
        galleryImages = allImages;
      }

      // Find current index
      currentImageIndex = galleryImages.findIndex(img => img.id === id);
      if (currentImageIndex === -1) return;

      currentModalId = id;
      updateModalDisplay();
      buildThumbnailStrip();
      document.getElementById('modal').classList.add('open');
      document.body.style.overflow = 'hidden';
    }

    function updateModalDisplay() {
      const img = galleryImages[currentImageIndex];
      if (!img) return;

      currentModalId = img.id;
      document.getElementById('modalImg').src = img.data;
      document.getElementById('modalInfo').textContent = JSON.stringify(img.settings, null, 2);
      document.getElementById('modalCounter').textContent = `${currentImageIndex + 1} / ${galleryImages.length}`;

      // Update prompt display with highlighting
      const modalPromptEl = document.getElementById('modalPrompt');
      const variables = img.settings?._variables || {};
      if (img.settings?.prompt) {
        // Always highlight - will catch builtin [] variables even without JSON variables
        modalPromptEl.innerHTML = highlightStoredPrompt(img.settings.prompt, variables);
      } else {
        modalPromptEl.innerHTML = '';
      }

      // Update name label
      const nameLabel = variables?.name;
      const nameLabelEl = document.getElementById('modalNameLabel');
      if (nameLabel) {
        nameLabelEl.textContent = nameLabel;
        nameLabelEl.style.display = 'block';
      } else {
        nameLabelEl.style.display = 'none';
      }

      // Update nav buttons
      document.getElementById('modalPrev').classList.toggle('disabled', currentImageIndex === 0);
      document.getElementById('modalNext').classList.toggle('disabled', currentImageIndex === galleryImages.length - 1);

      // For large galleries, rebuild the window; for small, just update active state
      if (galleryImages.length > THUMB_WINDOW * 2) {
        updateThumbnailWindow();
      } else {
        // Update active thumbnail
        document.querySelectorAll('.thumbnail').forEach((thumb, i) => {
          thumb.classList.toggle('active', i === currentImageIndex);
        });

        // Scroll thumbnail into view
        const activeThumb = document.querySelector('.thumbnail.active');
        if (activeThumb) {
          activeThumb.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
      }
    }

    const THUMB_WINDOW = 21; // Show 21 thumbnails at a time (10 on each side + current)

    function buildThumbnailStrip() {
      const strip = document.getElementById('thumbnailStrip');
      const total = galleryImages.length;

      // For small galleries, render all
      if (total <= THUMB_WINDOW * 2) {
        strip.innerHTML = galleryImages.map((img, i) => {
          const nameLabel = img.settings?._variables?.name;
          const thumbSrc = img.thumbnail || img.data;
          return `
          <div class="thumbnail ${i === currentImageIndex ? 'active' : ''}" onclick="goToImage(${i})">
            <img src="${thumbSrc}" alt="">
            ${nameLabel ? `<div class="thumb-name">${escapeHtml(nameLabel)}</div>` : ''}
          </div>
        `}).join('');
        return;
      }

      // For large galleries, use windowed rendering
      updateThumbnailWindow();
    }

    function updateThumbnailWindow() {
      const strip = document.getElementById('thumbnailStrip');
      const total = galleryImages.length;
      if (total <= THUMB_WINDOW * 2) return; // Let buildThumbnailStrip handle small galleries

      const halfWindow = Math.floor(THUMB_WINDOW / 2);
      let start = Math.max(0, currentImageIndex - halfWindow);
      let end = Math.min(total, currentImageIndex + halfWindow + 1);

      // Adjust window if at edges
      if (start === 0) end = Math.min(total, THUMB_WINDOW);
      if (end === total) start = Math.max(0, total - THUMB_WINDOW);

      let html = '';

      // Show "jump to start" button if not at beginning
      if (start > 0) {
        html += `<div class="thumbnail thumb-jump" onclick="goToImage(0)"><span>1</span></div>`;
        if (start > 1) html += `<div class="thumbnail thumb-ellipsis"><span>...</span></div>`;
      }

      // Render visible thumbnails
      for (let i = start; i < end; i++) {
        const img = galleryImages[i];
        const nameLabel = img.settings?._variables?.name;
        const thumbSrc = img.thumbnail || img.data;
        html += `
          <div class="thumbnail ${i === currentImageIndex ? 'active' : ''}" onclick="goToImage(${i})">
            <img src="${thumbSrc}" alt="">
            ${nameLabel ? `<div class="thumb-name">${escapeHtml(nameLabel)}</div>` : ''}
          </div>
        `;
      }

      // Show "jump to end" button if not at end
      if (end < total) {
        if (end < total - 1) html += `<div class="thumbnail thumb-ellipsis"><span>...</span></div>`;
        html += `<div class="thumbnail thumb-jump" onclick="goToImage(${total - 1})"><span>${total}</span></div>`;
      }

      strip.innerHTML = html;
    }

    function navigateModal(direction) {
      const newIndex = currentImageIndex + direction;
      if (newIndex < 0 || newIndex >= galleryImages.length) return;
      currentImageIndex = newIndex;
      updateModalDisplay();
    }

    function goToImage(index) {
      if (index < 0 || index >= galleryImages.length) return;
      currentImageIndex = index;
      updateModalDisplay();
    }

    function closeModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('modal').classList.remove('open');
      document.body.style.overflow = '';
      currentModalId = null;
      galleryImages = [];
    }

    async function deleteFromModal() {
      if (!currentModalId) return;
      if (!confirm('Delete this image?')) return;

      await deleteImage(currentModalId);
      galleryImages = galleryImages.filter(img => img.id !== currentModalId);

      if (galleryImages.length === 0) {
        closeModal();
      } else {
        // Stay at same index or go to previous if at end
        if (currentImageIndex >= galleryImages.length) {
          currentImageIndex = galleryImages.length - 1;
        }
        updateModalDisplay();
        buildThumbnailStrip();
      }

      await loadGallery();
      showToast('Image deleted');
    }

    async function reuseSettings(id) {
      const img = await getImage(id);
      if (!img) return;

      const s = img.settings;
      document.getElementById('prompt').value = s.prompt || '';
      document.getElementById('negativePrompt').value = s.negative_prompt || '';
      document.getElementById('steps').value = s.num_inference_steps || 9;
      document.getElementById('stepsValue').textContent = s.num_inference_steps || 9;
      document.getElementById('cfgScale').value = s.cfg_scale || 5;
      document.getElementById('cfgScaleValue').textContent = s.cfg_scale || 5;
      document.getElementById('seed').value = s.seed || -1;

      if (s.width && s.height) {
        document.getElementById('aspectRatio').value = 'custom';
        document.getElementById('customSize').style.display = 'block';
        document.getElementById('baseSizeRow').style.display = 'none';
        document.getElementById('width').value = s.width;
        document.getElementById('height').value = s.height;
      } else if (s.aspect_ratio) {
        document.getElementById('aspectRatio').value = s.aspect_ratio;
        document.getElementById('customSize').style.display = 'none';
        document.getElementById('baseSizeRow').style.display = 'block';
        if (s.base_size) {
          document.getElementById('baseSize').value = s.base_size;
          document.getElementById('baseSizeValue').textContent = s.base_size;
        }
      }

      closeModal();
      showToast('Settings applied');
    }

    async function downloadImage(id) {
      const img = await getImage(id);
      if (!img) return;

      const link = document.createElement('a');
      link.href = img.data;

      // Determine filename: use {name} variable if available, otherwise timestamp
      const name = img.settings?._variables?.name;
      const ext = img.data.startsWith('data:image/png') ? 'png' :
                  img.data.startsWith('data:image/jpeg') ? 'jpg' :
                  img.data.startsWith('data:image/webp') ? 'webp' : 'png';

      if (name) {
        // Sanitize filename (remove invalid characters)
        const safeName = name.replace(/[<>:"/\\|?*]/g, '_').trim();
        link.download = `${safeName}.${ext}`;
      } else {
        const timestamp = new Date(img.timestamp).toISOString().replace(/[:.]/g, '-').slice(0, 19);
        link.download = `silly-media-${timestamp}.${ext}`;
      }

      link.click();
      showToast('Image downloaded');
    }

    async function downloadZip() {
      // Get images for current folder
      const allImages = await getAllImages();
      let images = allImages;

      if (currentFolder !== 'all') {
        images = allImages.filter(img => img.folder === currentFolder);
      }

      if (images.length === 0) {
        showToast('No images to download');
        return;
      }

      const btn = document.getElementById('downloadZipBtn');
      const originalText = btn.textContent;
      btn.disabled = true;
      btn.textContent = 'Creating ZIP...';

      try {
        const zip = new JSZip();
        const usedNames = new Map(); // Track used filenames for uniqueness

        for (let i = 0; i < images.length; i++) {
          const img = images[i];

          // Update progress
          btn.textContent = `Zipping ${i + 1}/${images.length}...`;

          // Determine extension from data URL
          const ext = img.data.startsWith('data:image/png') ? 'png' :
                      img.data.startsWith('data:image/jpeg') ? 'jpg' :
                      img.data.startsWith('data:image/webp') ? 'webp' : 'png';

          // Determine base filename
          const name = img.settings?._variables?.name;
          let baseName;
          if (name) {
            baseName = name.replace(/[<>:"/\\|?*]/g, '_').trim();
          } else {
            const timestamp = new Date(img.timestamp).toISOString().replace(/[:.]/g, '-').slice(0, 19);
            baseName = `silly-media-${timestamp}`;
          }

          // Make filename unique
          let filename = `${baseName}.${ext}`;
          const count = usedNames.get(filename) || 0;
          if (count > 0) {
            filename = `${baseName}_${count}.${ext}`;
          }
          usedNames.set(`${baseName}.${ext}`, count + 1);

          // Convert data URL to blob
          const base64Data = img.data.split(',')[1];
          zip.file(filename, base64Data, { base64: true });
        }

        btn.textContent = 'Generating ZIP...';

        const content = await zip.generateAsync({ type: 'blob' }, (metadata) => {
          btn.textContent = `Compressing ${Math.round(metadata.percent)}%...`;
        });

        // Download the ZIP
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        const folderName = currentFolder === 'all' ? 'all-images' : currentFolder.replace(/[<>:"/\\|?*]/g, '_');
        link.download = `${folderName}.zip`;
        link.click();
        URL.revokeObjectURL(link.href);

        showToast(`Downloaded ${images.length} images as ZIP`);
      } catch (error) {
        console.error('ZIP creation failed:', error);
        showToast('Failed to create ZIP');
      } finally {
        btn.disabled = false;
        btn.textContent = originalText;
      }
    }

    // Copy functions
    function copyCurl() {
      const settings = getSettings();
      const url = `${getApiUrl()}/generate/${getModel()}`;
      const json = JSON.stringify(settings);
      const curl = `curl -X POST "${url}" \\
  -H "Content-Type: application/json" \\
  -d '${json}' \\
  --output image.png`;

      copyToClipboard(curl);
    }

    function copyJson() {
      const settings = getSettings();
      copyToClipboard(JSON.stringify(settings, null, 2));
    }

    function copyPython() {
      const settings = getSettings();
      const url = `${getApiUrl()}/generate/${getModel()}`;
      const code = `import requests

response = requests.post(
    "${url}",
    json=${JSON.stringify(settings, null, 4).replace(/"/g, '"')}
)

with open("image.png", "wb") as f:
    f.write(response.content)`;

      copyToClipboard(code);
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('Copied to clipboard');
      });
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2000);
    }

    function showVariablesHelp() {
      document.getElementById('helpModal').classList.add('open');
    }

    function closeHelpModal(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('helpModal').classList.remove('open');
    }

    // Settings
    const SETTINGS_STORAGE_KEY = 'sillyMediaAppSettings';

    function openSettings() {
      document.getElementById('settingsModal').classList.add('open');
    }

    function closeSettings(event) {
      if (event && event.target !== event.currentTarget) return;
      document.getElementById('settingsModal').classList.remove('open');
    }

    function saveSettings() {
      const settings = {
        debounce: parseInt(document.getElementById('settingDebounce').value)
      };
      localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
    }

    function loadAppSettings() {
      const saved = localStorage.getItem(SETTINGS_STORAGE_KEY);
      if (saved) {
        try {
          const settings = JSON.parse(saved);
          if (settings.debounce) {
            document.getElementById('settingDebounce').value = settings.debounce;
          }
        } catch (e) {}
      }
    }

    function getDebounceTime() {
      return parseInt(document.getElementById('settingDebounce').value) || 1000;
    }

    function showDebounceBar(duration) {
      const bar = document.getElementById('debounceBar');
      const fill = document.getElementById('debounceBarFill');
      if (!bar || !fill) return;

      bar.style.display = 'block';
      fill.classList.remove('animate');
      fill.style.setProperty('--debounce-duration', duration + 'ms');

      // Force reflow to restart animation
      void fill.offsetWidth;
      fill.classList.add('animate');
    }

    function hideDebounceBar() {
      const bar = document.getElementById('debounceBar');
      if (bar) bar.style.display = 'none';
    }

    // Batch generation
    function validateBatchJson() {
      const textarea = document.getElementById('batchJson');
      const errorEl = document.getElementById('jsonError');
      const validEl = document.getElementById('jsonValid');
      const text = textarea.value.trim();

      errorEl.classList.remove('show');
      validEl.classList.remove('show');

      if (!text) return null;

      try {
        const data = JSON.parse(text);
        if (!Array.isArray(data)) {
          throw new Error('JSON must be an array of objects');
        }
        if (data.length === 0) {
          throw new Error('Array is empty');
        }
        if (!data.every(item => typeof item === 'object' && item !== null && !Array.isArray(item))) {
          throw new Error('Each item must be an object');
        }

        // Get all variable names
        const allKeys = new Set();
        data.forEach(item => Object.keys(item).forEach(k => allKeys.add(k)));

        validEl.textContent = `Valid JSON: ${data.length} items with variables: ${Array.from(allKeys).join(', ')}`;
        validEl.classList.add('show');
        return data;
      } catch (e) {
        let message = e.message;
        // Try to provide more helpful error for JSON syntax errors
        if (e instanceof SyntaxError) {
          const match = e.message.match(/position (\d+)/);
          if (match) {
            const pos = parseInt(match[1]);
            const lines = text.substring(0, pos).split('\n');
            message = `Syntax error at line ${lines.length}, column ${lines[lines.length-1].length + 1}: ${e.message}`;
          }
        }
        errorEl.textContent = message;
        errorEl.classList.add('show');
        return null;
      }
    }

    // Built-in random variables
    const BUILTIN_VARS = {
      location: [
        'bedroom', 'living room', 'kitchen', 'bathroom', 'rooftop terrace', 'urban street', 'city alley', 'downtown plaza', 'subway station', 'parking garage', 'beach', 'tropical island', 'lakeside', 'riverbank', 'waterfall', 'forest', 'jungle', 'mountain peak', 'desert dunes', 'snowy wilderness', 'film studio', 'art gallery', 'library', 'coffee shop', 'nightclub', 'castle hall', 'space station', 'underwater ruins', 'neon-lit arcade', 'zen garden', 'slave market', 'strip club', 'brothel', 'back alley', 'arena', 'carnival', 'slum district', 'industrial factory', 'abandoned warehouse', 'school', 'university campus', 'hospital room', 'laboratory', 'labor camp', 'landfill site', 'junkyard', 'construction site', 'docks', 'ship deck', 'train yard', 'airport hangar', 'BDSM dungeon', 'torture chamber', 'prison cell', 'execution ground'
      ],
      time: [
        'at dawn', 'at sunrise', 'in the early morning', 'in the morning light', 'at midday', 'in the afternoon', 'in the golden hour', 'at sunset', 'at dusk', 'at twilight', 'in the evening', 'at night', 'at midnight', 'under moonlight', 'during blue hour', 'in the fog', 'during a thunderstorm', 'in the rain', 'during snowfall'
      ],
      weather: [
        'sunny', 'cloudy', 'overcast', 'rainy', 'stormy', 'snowy', 'foggy', 'misty', 'windy', 'clear skies'
      ],
      mood: [
        'peaceful', 'dramatic', 'mysterious', 'romantic', 'melancholic', 'energetic', 'serene', 'tense', 'joyful', 'contemplative'
      ],
      lighting: [
        'soft natural light', 'harsh sunlight', 'golden hour glow', 'neon lights', 'candlelight', 'moonlight', 'studio lighting', 'dramatic shadows', 'backlit silhouette', 'ambient glow', 'bioluminescent', 'fairy lights'
      ],
      color: [
        'red', 'crimson', 'scarlet', 'burgundy', 'coral', 'orange', 'tangerine', 'peach', 'amber', 'rust', 'yellow', 'gold', 'lemon', 'mustard', 'cream', 'green', 'emerald', 'olive', 'mint', 'sage', 'forest green', 'lime', 'blue', 'navy', 'cobalt', 'sky blue', 'teal', 'turquoise', 'cyan', 'indigo', 'purple', 'violet', 'lavender', 'plum', 'magenta', 'fuchsia',  'pink', 'rose', 'blush', 'salmon', 'hot pink', 'brown', 'chocolate', 'tan', 'beige', 'caramel', 'copper', 'black', 'charcoal', 'onyx', 'ebony', 'white', 'ivory', 'pearl', 'snow', 'gray', 'silver', 'slate', 'ash'
      ],
      size: ['small', 'medium', 'large'],
      pose: [
        'standing', 'sitting', 'kneeling', 'lying down', 'crouching', 'walking', 'running', 'jumping', 'dancing', 'leaning', 'stretching', 'reaching', 'pointing', 'waving', 'crossing arms', 'hands on hips', 'bending over', 'squatting', 'lounging', 'spreading legs', 'touching herself', 'holding hair', 'biting lip', 'arching back', 'aiming', 'saluting', 'praying', 'meditating', 'tied up', 'bound wrists', 'hogtied', 'spread eagle', 'on all fours', 'doggy style', 'whipped', 'suspended', 'leashed', 'collared', 'gagged', 'chastised', 'spanked', 'flogged', 'interrogated'
      ],
      object: [
        'chair', 'stool', 'bench', 'sofa', 'armchair', 'throne', 'bed', 'mattress', 'pillow', 'blanket', 'table', 'desk', 'counter', 'bar', 'floor', 'carpet', 'rug', 'stairs', 'ladder', 'railing', 'balcony', 'window sill', 'doorway', 'wall', 'column', 'pillar','rock', 'tree stump', 'log', 'swing', 'hammock', 'car hood', 'motorcycle', 'bicycle', 'boat', 'pool edge', 'fountain', 'bathtub', 'shower', 'St. Andrew\'s cross', 'pillory', 'cage', 'stocks', 'cross', 'altar', 'dungeon bench', 'torture rack', 'whipping post', 'examination table', 'operating table', 'gynecological chair', 'spank bench', 'bondage table', 'humiliation stool', 'flogging bench', 'restraint bed', 'slave block', 'pillory stand', 'bondage frame', 'crop', 'paddle', 'butt-plug', 'dildo', 'vibrator', 'anal beads', 'nipple clamps', 'ball gag', 'blindfold', 'collar and leash', 'spreaders', 'chastity belt', 'shackles', 'manacles', 'chains', 'shibari-ropes'
      ],
      race: [
        'caucasian', 'african', 'asian', 'latino', 'hispanic', 'middle eastern', 'indian', 'polynesian', 'native american', 'mediterranean', 'nordic', 'slavic', 'southeast asian', 'east asian', 'mixed race', 'biracial', 'black african', 'arab', 'persian', 'maori', 'pacific islander', 'caribbean', 'afro-latino'
      ],
      expression: [
        'smiling', 'laughing', 'grinning', 'giggling', 'serious', 'stern', 'stoic', 'neutral', 'sad', 'crying', 'tearful', 'melancholic', 'angry', 'furious', 'annoyed', 'frowning', 'surprised', 'shocked', 'amazed', 'wide-eyed', 'seductive', 'flirty', 'sultry', 'playful', 'thoughtful', 'pensive', 'contemplative', 'dreamy', 'scared', 'terrified', 'worried', 'anxious', 'disgusted', 'confused', 'skeptical', 'bored', 'curious', 'determined', 'relaxed', 'content', 'excited', 'nervous', 'shy', 'proud', 'embarrassed', 'teasing', 'mischievous', 'smeared lipstick', 'running-makeup', 'smudged-makeup', 'dilated-pupils', 'biting-lip', 'tongue out', 'blushing', 'wide-smile', 'raised-eyebrow', 'humiliated', 'submissive', 'obedient', 'eager', 'desperate', 'pleading', 'yearning', 'aroused', 'lustful', 'devilish-grin', 'hypnotized', 'enslaved', 'mind controlled', 'brainwashed', 'broken', 'degraded', 'objectified', 'used', 'owned', 'slutty', 'whorish', 'prostitute', 'street whore', 'relaxed', 'dumb'
      ],
      hairstyle: [
        'with long straight hair', 'with long wavy hair', 'with long curly hair',  'with medium straight hair', 'with medium wavy hair', 'with medium curly hair', 'with short straight hair', 'with short wavy hair', 'with short curly hair', 'with a bob cut', 'with a pixie cut', 'with an undercut', 'with a ponytail', 'with a high ponytail', 'with a side ponytail', 'with a bun', 'with a messy bun', 'with a top knot', 'with braids', 'with a french braid', 'with box braids', 'with pigtails', 'with twin tails', 'with space buns', 'with bangs', 'with side swept bangs', 'with curtain bangs', 'with an updo', 'with loose waves', 'with hair down'
      ],
      haircolor: [
        'blonde', 'platinum blonde', 'golden blonde', 'strawberry blonde', 'brunette', 'brown', 'light brown', 'dark brown', 'chestnut', 'black', 'jet black', 'raven', 'red', 'ginger', 'auburn', 'copper',  'gray', 'silver', 'white', 'pink', 'blue', 'purple', 'green', 'rainbow', 'ombre'
      ]
    };

    // Combine hairstyle with color: "with long wavy hair" + "blonde" = "with long wavy blonde hair"
    function getHairstyleWithColor() {
      const style = getRandomBuiltin('hairstyle');
      const color = getRandomBuiltin('haircolor');
      // Insert color before "hair", or add "hair" at end for styles without it
      if (style.includes(' hair')) {
        return style.replace(' hair', ` ${color} hair`);
      } else if (style.startsWith('with a ')) {
        // "with a ponytail" -> "with a blonde ponytail hair"
        return 'with a ' + color + ' ' + style.slice(7) + ' hair';
      } else if (style.startsWith('with an ')) {
        // "with an updo" -> "with a blonde updo hair"
        return 'with a ' + color + ' ' + style.slice(8) + ' hair';
      } else if (style.startsWith('with ')) {
        // "with braids" -> "with blonde braids hair"
        return 'with ' + color + ' ' + style.slice(5) + ' hair';
      }
      return style; // fallback
    }

    function getRandomBuiltin(key) {
      const values = BUILTIN_VARS[key.toLowerCase()];
      if (!values) return null;
      return values[Math.floor(Math.random() * values.length)];
    }

    function interpolatePrompt(template, variables, batchData = null, currentIndex = 0) {
      // First, replace special combo variables like [hairstyle-color]
      let result = template.replace(/\[hairstyle-color\]/gi, () => getHairstyleWithColor());

      // Then, replace number range variables [N-M] like [30-40]
      result = result.replace(/\[(\d+)-(\d+)\]/g, (match, min, max) => {
        const minNum = parseInt(min, 10);
        const maxNum = parseInt(max, 10);
        if (minNum > maxNum) return match; // Invalid range
        return Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum;
      });

      // Then, replace built-in random variables [location], [time], etc.
      result = result.replace(/\[(\w+)\]/g, (match, key) => {
        const value = getRandomBuiltin(key);
        return value !== null ? value : match;
      });

      // Then, replace {variable} or {variable+N} or {variable-N}
      result = result.replace(/\{(\w+)([+-]\d+)?\}/g, (match, key, offset) => {
        if (offset && batchData) {
          // Relative reference like {name+1} or {name-1}
          const offsetNum = parseInt(offset, 10);
          const total = batchData.length;
          // Circular index: wrap around to beginning/end
          const targetIndex = ((currentIndex + offsetNum) % total + total) % total;
          const targetVars = batchData[targetIndex];
          return targetVars?.hasOwnProperty(key) ? targetVars[key] : match;
        }
        // Regular reference like {name}
        return variables.hasOwnProperty(key) ? variables[key] : match;
      });

      return result;
    }

    // Fisher-Yates shuffle
    function shuffleArray(array) {
      const arr = [...array]; // copy
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function saveBatchRandomize() {
      localStorage.setItem('sillyMediaBatchRandomize', document.getElementById('batchRandomize').checked);
    }

    function loadBatchRandomize() {
      const saved = localStorage.getItem('sillyMediaBatchRandomize');
      if (saved !== null) {
        document.getElementById('batchRandomize').checked = saved === 'true';
      }
    }

    async function generateBatch() {
      let batchData = validateBatchJson();
      if (!batchData) {
        showStatus('Please enter valid JSON', 'error');
        return;
      }

      // Randomize order if checkbox is checked
      if (document.getElementById('batchRandomize').checked) {
        batchData = shuffleArray(batchData);
      }

      const promptTemplate = document.getElementById('prompt').value.trim();
      if (!promptTemplate) {
        showStatus('Please enter a prompt template with {variables}', 'error');
        return;
      }

      // Create a folder name for this batch
      const folderName = `Batch ${new Date().toLocaleString()}`;

      const btn = document.getElementById('batchGenerateBtn');
      const cancelBtn = document.getElementById('batchCancelBtn');
      const progressEl = document.getElementById('batchProgress');
      const progressFill = document.getElementById('batchProgressFill');
      const progressText = document.getElementById('batchProgressText');
      const batchNamesEl = document.getElementById('batchNames');

      btn.style.display = 'none';
      cancelBtn.style.display = 'block';
      progressEl.style.display = 'block';
      batchCancelled = false;

      const total = batchData.length;
      let completed = 0;

      // Find all {name} references with offsets in the prompt
      function findNameReferences(template) {
        const refs = [];
        const regex = /\{name([+-]\d+)?\}/g;
        let match;
        while ((match = regex.exec(template)) !== null) {
          const offset = match[1] ? parseInt(match[1], 10) : 0;
          if (!refs.includes(offset)) refs.push(offset);
        }
        return refs.sort((a, b) => a - b);
      }

      const nameRefs = findNameReferences(promptTemplate);

      // Helper to update batch names display showing all referenced names
      function updateBatchNames(index) {
        if (nameRefs.length === 0 || !batchData[0]?.name) {
          batchNamesEl.innerHTML = '';
          return;
        }

        const total = batchData.length;
        const names = nameRefs.map(offset => {
          const targetIndex = ((index + offset) % total + total) % total;
          const name = batchData[targetIndex]?.name || '?';
          const label = offset === 0 ? '' : (offset > 0 ? `+${offset}` : `${offset}`);
          const isMain = offset === 0;
          return { name, label, isMain };
        });

        let html = names.map(({ name, label, isMain }) => {
          if (isMain) {
            return `<span class="current-name">${escapeHtml(name)}</span>`;
          } else {
            return `<span class="ref-name">${escapeHtml(name)}<sup>${label}</sup></span>`;
          }
        }).join('<span class="arrow">+</span>');

        batchNamesEl.innerHTML = html;
      }

      for (let i = 0; i < batchData.length; i++) {
        if (batchCancelled) {
          showStatus(`Batch cancelled after ${completed} images`, 'error');
          break;
        }

        const variables = batchData[i];
        const prompt = interpolatePrompt(promptTemplate, variables, batchData, i);
        const negativeTemplate = document.getElementById('negativePrompt').value;
        const negativePrompt = interpolatePrompt(negativeTemplate, variables, batchData, i);

        progressText.textContent = `${i + 1} / ${total}`;
        progressFill.style.width = `${(i / total) * 100}%`;
        updateBatchNames(i);

        // Show current prompt in progress area
        document.getElementById('batchPrompt').textContent = prompt;

        const settings = getSettings();
        settings.prompt = prompt;
        if (negativePrompt) settings.negative_prompt = negativePrompt;
        settings._variables = variables; // Store variables for name display

        const url = `${getApiUrl()}/generate/${getModel()}`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || error.error || 'Generation failed');
          }

          const blob = await response.blob();

          // Save with folder
          await saveImage(blob, settings, folderName);
          completed++;

          // Update progress
          progressFill.style.width = `${((i + 1) / total) * 100}%`;

          // Show preview with highlighted prompt
          const imgUrl = URL.createObjectURL(blob);
          showPreview(imgUrl, null, prompt, promptTemplate, variables, batchData, i);

          // Debounce between generations to let GPU breathe
          if (i < batchData.length - 1) {
            const debounceTime = getDebounceTime();
            showDebounceBar(debounceTime);
            await new Promise(r => setTimeout(r, debounceTime));
            hideDebounceBar();
          }

        } catch (error) {
          console.error(`Failed to generate image ${i + 1}:`, error);
          showStatus(`Error on image ${i + 1}: ${error.message}`, 'error');
          // Continue with next image instead of stopping
        }
      }
      hideDebounceBar();

      btn.style.display = 'block';
      cancelBtn.style.display = 'none';
      cancelBtn.textContent = 'Cancel Batch'; // Reset button text
      progressEl.style.display = 'none';
      batchNamesEl.innerHTML = '';
      document.getElementById('batchPrompt').textContent = '';

      if (!batchCancelled) {
        showStatus(`Batch complete: ${completed}/${total} images`, 'success');
      }

      await loadGallery();
      // Switch to the new folder
      currentFolder = folderName;
      await loadGallery();
    }

    function cancelBatch() {
      batchCancelled = true;
      document.getElementById('batchCancelBtn').textContent = 'Cancelling...';
    }

    // Simple batch generation (no JSON, just repeat with random [] variables)
    async function generateSimpleBatch() {
      const promptTemplate = document.getElementById('prompt').value.trim();
      if (!promptTemplate) {
        showStatus('Please enter a prompt', 'error');
        return;
      }

      // Check for {variable} - not allowed in simple batch
      if (/\{(\w+)([+-]\d+)?\}/.test(promptTemplate)) {
        showStatus('{variables} require JSON batch mode. Use [] for random values.', 'error');
        return;
      }

      const count = parseInt(document.getElementById('simpleBatchCount').value) || 10;
      if (count < 1 || count > 100) {
        showStatus('Count must be between 1 and 100', 'error');
        return;
      }

      // Create folder name
      const folderName = `Simple ${new Date().toLocaleString()}`;

      const btn = document.getElementById('simpleBatchBtn');
      const cancelBtn = document.getElementById('simpleBatchCancelBtn');
      const progressEl = document.getElementById('simpleBatchProgress');
      const progressFill = document.getElementById('simpleBatchProgressFill');
      const progressText = document.getElementById('simpleBatchProgressText');
      const batchPromptEl = document.getElementById('simpleBatchPrompt');

      btn.style.display = 'none';
      cancelBtn.style.display = 'block';
      progressEl.style.display = 'block';
      simpleBatchCancelled = false;

      let completed = 0;

      for (let i = 0; i < count; i++) {
        if (simpleBatchCancelled) {
          showStatus(`Batch cancelled after ${completed} images`, 'error');
          break;
        }

        // Interpolate with fresh random values for each image
        const prompt = interpolatePrompt(promptTemplate, {});
        const negativeTemplate = document.getElementById('negativePrompt').value;
        const negativePrompt = interpolatePrompt(negativeTemplate, {});

        progressText.textContent = `${i + 1} / ${count}`;
        progressFill.style.width = `${(i / count) * 100}%`;
        batchPromptEl.textContent = prompt;

        const settings = getSettings();
        settings.prompt = prompt;
        if (negativePrompt && negativePrompt.trim()) {
          settings.negative_prompt = negativePrompt;
        }

        const url = `${getApiUrl()}/generate/${getModel()}`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(settings)
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || error.error || 'Generation failed');
          }

          const blob = await response.blob();

          // Save with folder
          await saveImage(blob, settings, folderName);
          completed++;

          // Update progress
          progressFill.style.width = `${((i + 1) / count) * 100}%`;

          // Show preview
          const imgUrl = URL.createObjectURL(blob);
          showPreview(imgUrl, null, prompt);

          // Debounce between generations
          if (i < count - 1) {
            const debounceTime = getDebounceTime();
            showDebounceBar(debounceTime);
            await new Promise(r => setTimeout(r, debounceTime));
            hideDebounceBar();
          }

        } catch (error) {
          console.error(`Failed to generate image ${i + 1}:`, error);
          showStatus(`Error on image ${i + 1}: ${error.message}`, 'error');
        }
      }
      hideDebounceBar();

      btn.style.display = 'block';
      cancelBtn.style.display = 'none';
      cancelBtn.textContent = 'Cancel';
      progressEl.style.display = 'none';
      batchPromptEl.textContent = '';

      if (!simpleBatchCancelled) {
        showStatus(`Batch complete: ${completed}/${count} images`, 'success');
      }

      await loadGallery();
      currentFolder = folderName;
      await loadGallery();
    }

    function cancelSimpleBatch() {
      simpleBatchCancelled = true;
      document.getElementById('simpleBatchCancelBtn').textContent = 'Cancelling...';
    }

    // Initialize on load
    init();
  </script>
</body>
</html>
