<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Silly Media - Text to Speech</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --surface2: #0f3460;
      --accent: #e94560;
      --accent2: #533483;
      --text: #eee;
      --text-dim: #888;
      --success: #4ade80;
      --warning: #fbbf24;
      --radius: 8px;
    }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 520px 1fr;
      gap: 20px;
    }
    @media (max-width: 1100px) {
      .container { grid-template-columns: 1fr; }
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    h1 { font-size: 1.5rem; color: var(--accent); }
    .header-links a {
      color: var(--text-dim);
      text-decoration: none;
      font-size: 0.85rem;
      margin-left: 16px;
    }
    .header-links a:hover { color: var(--text); }

    h2 { font-size: 1.1rem; margin-bottom: 12px; color: var(--text-dim); }
    h3 { font-size: 0.95rem; margin-bottom: 8px; color: var(--text); }

    /* Panel styles */
    .panel {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
    }
    .controls {
      position: sticky;
      top: 20px;
      display: flex;
      flex-direction: column;
      height: calc(100vh - 120px);
    }
    .tab-content {
      display: none;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }
    .tab-content.active {
      display: flex;
    }

    /* Form elements */
    label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 4px;
    }
    textarea, input, select {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--surface2);
      border-radius: var(--radius);
      background: var(--bg);
      color: var(--text);
      font-size: 0.95rem;
      margin-bottom: 12px;
    }
    textarea { resize: vertical; min-height: 120px; font-family: inherit; }
    textarea:focus, input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }
    input[type="range"] {
      padding: 0;
      margin-bottom: 4px;
    }

    /* Grid layouts */
    .row { display: flex; gap: 12px; }
    .row > * { flex: 1; }
    .row-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }

    /* Buttons */
    button {
      padding: 10px 16px;
      border: none;
      border-radius: var(--radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: var(--accent);
      color: white;
      font-weight: 600;
    }
    .btn-primary:hover { filter: brightness(1.1); }
    .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-secondary {
      background: var(--surface2);
      color: var(--text);
    }
    .btn-secondary:hover { background: var(--accent2); }
    .btn-small {
      padding: 6px 10px;
      font-size: 0.8rem;
    }
    .btn-danger { background: #dc2626; color: white; }
    .btn-danger:hover { background: #b91c1c; }
    .btn-icon {
      background: transparent;
      color: var(--text-dim);
      padding: 6px;
    }
    .btn-icon:hover { color: var(--text); }

    .btn-group { display: flex; gap: 8px; margin-top: 16px; }
    .btn-group button { flex: 1; }

    /* Generate button */
    #generateBtn {
      width: 100%;
      padding: 14px;
      font-size: 1rem;
      margin-top: 8px;
    }

    /* Status */
    .status {
      margin-top: 12px;
      padding: 10px;
      border-radius: var(--radius);
      font-size: 0.85rem;
      display: none;
    }
    .status.error { display: block; background: #dc262633; color: #fca5a5; }
    .status.success { display: block; background: #16a34a33; color: var(--success); }
    .status.loading { display: block; background: var(--surface2); color: var(--text-dim); }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      background: var(--bg);
      padding: 4px;
      border-radius: var(--radius);
    }
    .tab {
      flex: 1;
      padding: 10px;
      background: transparent;
      color: var(--text-dim);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }
    .tab:hover { color: var(--text); }
    .tab.active {
      background: var(--surface2);
      color: var(--text);
    }

    /* Actor list */
    .actor-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      overflow-y: auto;
      margin-bottom: 12px;
      min-height: 200px;
    }
    .actor-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius);
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    .actor-item:hover { border-color: var(--surface2); }
    .actor-item.selected { border-color: var(--accent); }
    .actor-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--accent2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      flex-shrink: 0;
    }
    .actor-info { flex: 1; min-width: 0; }
    .actor-name {
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .actor-meta {
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    .actor-actions {
      display: flex;
      gap: 4px;
    }

    /* File upload */
    .upload-zone {
      border: 2px dashed var(--surface2);
      border-radius: var(--radius);
      padding: 30px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 12px;
    }
    .upload-zone:hover, .upload-zone.dragover {
      border-color: var(--accent);
      background: rgba(233, 69, 96, 0.1);
    }
    .upload-zone input { display: none; }
    .upload-icon { font-size: 2rem; margin-bottom: 8px; }
    .upload-text { color: var(--text-dim); font-size: 0.9rem; }
    .upload-hint { color: var(--text-dim); font-size: 0.75rem; margin-top: 4px; }

    /* File list */
    .file-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }
    .file-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg);
      border-radius: var(--radius);
      font-size: 0.85rem;
    }
    .file-item .file-icon { color: var(--accent); }
    .file-item .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-item .file-size { color: var(--text-dim); font-size: 0.8rem; }
    .file-item .file-remove {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      padding: 2px;
    }
    .file-item .file-remove:hover { color: #dc2626; }

    /* Audio player section */
    .audio-section {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 20px;
    }
    .audio-player-container {
      background: var(--bg);
      border-radius: var(--radius);
      padding: 20px;
      text-align: center;
    }
    .audio-player-container audio {
      width: 100%;
      margin-bottom: 12px;
    }
    .audio-placeholder {
      color: var(--text-dim);
      padding: 40px;
    }
    .audio-info {
      display: flex;
      justify-content: center;
      gap: 20px;
      font-size: 0.85rem;
      color: var(--text-dim);
    }
    .audio-actions {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 12px;
    }

    /* History */
    .history-section {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
    }
    .history-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 400px;
      overflow-y: auto;
    }
    .history-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s;
    }
    .history-item:hover { background: var(--surface2); }
    .history-item.playing { border-left: 3px solid var(--accent); }
    .history-play {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: var(--accent);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      border: none;
      cursor: pointer;
    }
    .history-play:hover { filter: brightness(1.1); }
    .history-info { flex: 1; min-width: 0; }
    .history-text {
      font-size: 0.9rem;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }
    .history-meta {
      font-size: 0.75rem;
      color: var(--text-dim);
    }
    .history-download {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      padding: 4px;
    }
    .history-download:hover { color: var(--text); }
    .history-delete {
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      padding: 4px;
    }
    .history-delete:hover { color: #dc2626; }
    .history-actions {
      display: flex;
      gap: 4px;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }
    .modal.show { display: flex; }
    .modal-content {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .modal-header h3 { margin: 0; color: var(--text); font-size: 1.1rem; }
    .modal-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .modal-close:hover { color: var(--text); }

    /* Range with value */
    .range-group {
      margin-bottom: 12px;
    }
    .range-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .range-value {
      font-size: 0.85rem;
      color: var(--accent);
      font-weight: 600;
    }

    /* Backend status indicator */
    .backend-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-dim);
    }
    .status-dot.connected { background: var(--success); }
    .status-dot.loading { background: var(--warning); animation: pulse 1s infinite; }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-dim);
    }
    .empty-state-icon { font-size: 2rem; margin-bottom: 8px; }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--surface2); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent2); }

    /* Character count */
    .char-count {
      font-size: 0.75rem;
      color: var(--text-dim);
      text-align: right;
      margin-top: -8px;
      margin-bottom: 8px;
    }
    .char-count.warning { color: var(--warning); }
    .char-count.error { color: #dc2626; }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--surface2);
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <h1>Silly Media - Text to Speech</h1>
      <div class="header-links">
        <span class="backend-status">
          <span class="status-dot" id="statusDot"></span>
          <span id="statusText">Connecting...</span>
        </span>
        <a href="ui.html">üñºÔ∏è Images</a>
        <a href="/docs" target="_blank">API Docs</a>
      </div>
    </div>

    <!-- Left Panel - Controls -->
    <div class="panel controls">
      <!-- Tabs -->
      <div class="tabs">
        <button class="tab active" data-tab="generate">Generate</button>
        <button class="tab" data-tab="actors">Actors</button>
      </div>

      <!-- Generate Tab -->
      <div class="tab-content active" id="tab-generate">
        <label for="actorSelect">Voice Actor</label>
        <select id="actorSelect">
          <option value="">Select an actor...</option>
        </select>

        <label for="textInput">Text to Speak</label>
        <textarea id="textInput" placeholder="Enter the text you want to convert to speech..."></textarea>
        <div class="char-count"><span id="charCount">0</span> / 10,000</div>

        <div class="row">
          <div>
            <label for="languageSelect">Language</label>
            <select id="languageSelect">
              <option value="en">English</option>
              <option value="es">Spanish</option>
              <option value="fr">French</option>
              <option value="de">German</option>
              <option value="it">Italian</option>
              <option value="pt">Portuguese</option>
              <option value="pl">Polish</option>
              <option value="tr">Turkish</option>
              <option value="ru">Russian</option>
              <option value="nl">Dutch</option>
              <option value="cs">Czech</option>
              <option value="ar">Arabic</option>
              <option value="zh-cn">Chinese</option>
              <option value="ja">Japanese</option>
              <option value="hu">Hungarian</option>
              <option value="ko">Korean</option>
              <option value="hi">Hindi</option>
            </select>
          </div>
        </div>

        <div class="range-group">
          <div class="range-header">
            <label for="speedRange">Speed</label>
            <span class="range-value" id="speedValue">1.0x</span>
          </div>
          <input type="range" id="speedRange" min="0.5" max="2.0" step="0.1" value="1.0">
        </div>

        <div class="range-group">
          <div class="range-header">
            <label for="tempRange">Temperature</label>
            <span class="range-value" id="tempValue">0.65</span>
          </div>
          <input type="range" id="tempRange" min="0.0" max="1.0" step="0.05" value="0.65">
        </div>

        <div style="margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="splitSentences" checked style="margin: 0; width: 16px; height: 16px;">
            <span>Split into sentences</span>
          </label>
        </div>

        <div style="margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="useStreaming" style="margin: 0; width: 16px; height: 16px;">
            <span>Use streaming (lower latency)</span>
          </label>
        </div>

        <button id="generateBtn" class="btn-primary">Generate Speech</button>

        <div id="status" class="status"></div>
      </div>

      <!-- Actors Tab -->
      <div class="tab-content" id="tab-actors">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <h3 style="margin-bottom: 0;">Your Actors</h3>
          <span id="actorCount" style="font-size: 0.8rem; color: var(--text-dim);"></span>
        </div>
        <input type="text" id="actorSearch" placeholder="Search actors..." style="margin-bottom: 12px;">
        <div class="actor-list" id="actorList">
          <div class="empty-state">
            <div class="empty-state-icon">üé≠</div>
            <div>No actors yet</div>
          </div>
        </div>

        <button class="btn-primary" style="width: 100%;" onclick="showCreateActorModal()">
          + Create New Actor
        </button>
      </div>
    </div>

    <!-- Right Panel - Output -->
    <div class="right-panel">
      <!-- Audio Player -->
      <div class="audio-section">
        <h2>Generated Audio</h2>
        <div class="audio-player-container" id="audioContainer">
          <div class="audio-placeholder" id="audioPlaceholder">
            <div style="font-size: 2rem; margin-bottom: 8px;">üîä</div>
            <div>Generated audio will appear here</div>
          </div>
          <div id="audioPlayerWrapper" style="display: none;">
            <audio id="audioPlayer" controls></audio>
            <div class="audio-info" id="audioInfo"></div>
            <div class="audio-actions">
              <button class="btn-secondary btn-small" onclick="downloadAudio()">Download WAV</button>
              <button class="btn-secondary btn-small" onclick="copyAudioInfo()">Copy Info</button>
            </div>
          </div>
        </div>
      </div>

      <!-- History -->
      <div class="history-section">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h2 style="margin-bottom: 0;">History</h2>
          <span id="historyCount" style="font-size: 0.8rem; color: var(--text-dim);"></span>
        </div>
        <input type="text" id="historySearch" placeholder="Search history..." style="margin-bottom: 12px;">
        <div class="history-list" id="historyList">
          <div class="empty-state">
            <div class="empty-state-icon">üìú</div>
            <div>No history yet</div>
          </div>
        </div>
        <div class="pagination" id="historyPagination" style="display: none;">
          <button class="btn-secondary btn-small" id="prevPageBtn" onclick="changePage(-1)">‚Üê Prev</button>
          <span id="pageInfo" style="font-size: 0.85rem; color: var(--text-dim);"></span>
          <button class="btn-secondary btn-small" id="nextPageBtn" onclick="changePage(1)">Next ‚Üí</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Create Actor Modal -->
  <div class="modal" id="createActorModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Create New Actor</h3>
        <button class="modal-close" onclick="hideCreateActorModal()">&times;</button>
      </div>

      <label for="actorName">Actor Name</label>
      <input type="text" id="actorName" placeholder="e.g., Morgan Freeman">

      <label for="actorLanguage">Primary Language</label>
      <select id="actorLanguage">
        <option value="en">English</option>
        <option value="es">Spanish</option>
        <option value="fr">French</option>
        <option value="de">German</option>
        <option value="it">Italian</option>
        <option value="pt">Portuguese</option>
        <option value="pl">Polish</option>
        <option value="tr">Turkish</option>
        <option value="ru">Russian</option>
        <option value="nl">Dutch</option>
        <option value="cs">Czech</option>
        <option value="ar">Arabic</option>
        <option value="zh-cn">Chinese</option>
        <option value="ja">Japanese</option>
        <option value="hu">Hungarian</option>
        <option value="ko">Korean</option>
        <option value="hi">Hindi</option>
      </select>

      <label for="actorDescription">Description (optional)</label>
      <input type="text" id="actorDescription" placeholder="e.g., Deep narrator voice">

      <!-- Source tabs -->
      <label>Audio Source</label>
      <div class="tabs" style="margin-bottom: 12px;">
        <button class="tab active" data-source="upload" onclick="switchSourceTab('upload')">Upload Files</button>
        <button class="tab" data-source="youtube" onclick="switchSourceTab('youtube')">YouTube URL</button>
      </div>

      <!-- Upload source -->
      <div id="sourceUpload" class="source-content">
        <div class="upload-zone" id="uploadZone">
          <input type="file" id="audioFiles" accept="audio/*" multiple>
          <div class="upload-icon">üé§</div>
          <div class="upload-text">Drop audio files here or click to browse</div>
          <div class="upload-hint">WAV, MP3, FLAC, OGG - Min 6 seconds recommended</div>
        </div>
        <div class="file-list" id="fileList"></div>
      </div>

      <!-- YouTube source -->
      <div id="sourceYoutube" class="source-content" style="display: none;">
        <input type="text" id="youtubeUrl" placeholder="https://youtube.com/watch?v=..." style="margin-bottom: 8px;">
        <div id="youtubeValidation" style="font-size: 0.8rem; margin-bottom: 12px; min-height: 20px;"></div>

        <div style="margin-bottom: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="separateVocals" checked style="margin: 0; width: 16px; height: 16px;">
            <span>Remove background music (recommended)</span>
          </label>
        </div>

        <div class="range-group">
          <div class="range-header">
            <label for="maxDuration">Max Duration</label>
            <span class="range-value" id="maxDurationValue">30s</span>
          </div>
          <input type="range" id="maxDuration" min="10" max="120" step="5" value="30">
          <div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 4px;">30-60s recommended for best quality</div>
        </div>
      </div>

      <div class="btn-group">
        <button class="btn-secondary" onclick="hideCreateActorModal()">Cancel</button>
        <button class="btn-primary" id="createActorBtn" onclick="createActor()">Create Actor</button>
      </div>

      <div id="modalStatus" class="status"></div>
    </div>
  </div>

  <!-- Actor Details Modal -->
  <div class="modal" id="actorDetailsModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="actorDetailsName">Actor Details</h3>
        <button class="modal-close" onclick="hideActorDetailsModal()">&times;</button>
      </div>

      <div style="margin-bottom: 16px;">
        <div style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 4px;">Language</div>
        <div id="actorDetailsLang">-</div>
      </div>

      <div style="margin-bottom: 16px;">
        <div style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 4px;">Description</div>
        <div id="actorDetailsDesc">-</div>
      </div>

      <div style="margin-bottom: 16px;">
        <div style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 8px;">Audio Files</div>
        <div id="actorAudioFiles"></div>
      </div>

      <label>Add More Audio</label>
      <div class="upload-zone" id="addAudioZone">
        <input type="file" id="addAudioFile" accept="audio/*">
        <div class="upload-icon">‚ûï</div>
        <div class="upload-text">Add another reference audio</div>
      </div>

      <div class="btn-group">
        <button class="btn-danger" id="deleteActorBtn">Delete Actor</button>
        <button class="btn-secondary" onclick="hideActorDetailsModal()">Close</button>
      </div>

      <div id="detailsModalStatus" class="status"></div>
    </div>
  </div>

  <script>
    // Use localhost when opened from file://, otherwise same origin
    const API_BASE = window.location.protocol === 'file:' ? 'http://localhost:4201' : '';

    // State
    let actors = [];
    let selectedActorName = '';
    let currentAudio = null;
    let history = [];
    let uploadedFiles = [];
    let currentActorForDetails = null;

    // Pagination state
    const ITEMS_PER_PAGE = 10;
    let currentPage = 1;
    let historySearchTerm = '';
    let actorSearchTerm = '';

    // Elements
    const actorSelect = document.getElementById('actorSelect');
    const textInput = document.getElementById('textInput');
    const charCount = document.getElementById('charCount');
    const languageSelect = document.getElementById('languageSelect');
    const speedRange = document.getElementById('speedRange');
    const speedValue = document.getElementById('speedValue');
    const tempRange = document.getElementById('tempRange');
    const tempValue = document.getElementById('tempValue');
    const splitSentences = document.getElementById('splitSentences');
    const useStreaming = document.getElementById('useStreaming');
    const generateBtn = document.getElementById('generateBtn');
    const status = document.getElementById('status');
    const audioPlayer = document.getElementById('audioPlayer');
    const audioPlaceholder = document.getElementById('audioPlaceholder');
    const audioPlayerWrapper = document.getElementById('audioPlayerWrapper');
    const audioInfo = document.getElementById('audioInfo');
    const historyList = document.getElementById('historyList');
    const actorList = document.getElementById('actorList');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      loadActors();
      checkBackendStatus();
      setupEventListeners();
      loadHistory();
      loadSettings();

      // Check backend status every 10 seconds
      setInterval(checkBackendStatus, 10000);
    });

    // Settings persistence
    function saveSettings() {
      const settings = {
        actor: actorSelect.value,
        text: textInput.value,
        language: languageSelect.value,
        speed: speedRange.value,
        temperature: tempRange.value,
        splitSentences: splitSentences.checked,
        useStreaming: useStreaming.checked
      };
      localStorage.setItem('tts_settings', JSON.stringify(settings));
    }

    function loadSettings() {
      try {
        const saved = localStorage.getItem('tts_settings');
        if (!saved) return;
        const settings = JSON.parse(saved);

        if (settings.text) textInput.value = settings.text;
        if (settings.language) languageSelect.value = settings.language;
        if (settings.speed) {
          speedRange.value = settings.speed;
          speedValue.textContent = `${settings.speed}x`;
        }
        if (settings.temperature) {
          tempRange.value = settings.temperature;
          tempValue.textContent = settings.temperature;
        }
        if (typeof settings.splitSentences === 'boolean') {
          splitSentences.checked = settings.splitSentences;
        }
        if (typeof settings.useStreaming === 'boolean') {
          useStreaming.checked = settings.useStreaming;
          // Disable split sentences if streaming is enabled
          if (settings.useStreaming) {
            splitSentences.checked = false;
            splitSentences.disabled = true;
            splitSentences.parentElement.style.opacity = '0.5';
          }
        }
        // Actor will be restored after actors load
        if (settings.actor) {
          selectedActorName = settings.actor;
        }
        // Update char count
        charCount.textContent = textInput.value.length.toLocaleString();
      } catch (e) {
        console.error('Failed to load settings:', e);
      }
    }

    function setupEventListeners() {
      // Main tabs (Generate/Actors) - only those with data-tab attribute in the controls panel
      document.querySelectorAll('.controls > .tabs > .tab[data-tab]').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.controls > .tabs > .tab').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(`tab-${tab.dataset.tab}`).classList.add('active');
        });
      });

      // Character count
      textInput.addEventListener('input', () => {
        const len = textInput.value.length;
        charCount.textContent = len.toLocaleString();
        charCount.parentElement.classList.remove('warning', 'error');
        if (len > 9000) charCount.parentElement.classList.add('warning');
        if (len > 10000) charCount.parentElement.classList.add('error');
        saveSettings();
      });

      // Range sliders
      speedRange.addEventListener('input', () => {
        speedValue.textContent = `${speedRange.value}x`;
        saveSettings();
      });
      tempRange.addEventListener('input', () => {
        tempValue.textContent = tempRange.value;
        saveSettings();
      });

      // Generate button
      generateBtn.addEventListener('click', generateSpeech);

      // Actor select
      actorSelect.addEventListener('change', () => {
        selectedActorName = actorSelect.value;
        saveSettings();
      });

      // Language select
      languageSelect.addEventListener('change', saveSettings);

      // Split sentences checkbox
      splitSentences.addEventListener('change', saveSettings);

      // Streaming checkbox - disable split sentences when streaming
      useStreaming.addEventListener('change', () => {
        if (useStreaming.checked) {
          splitSentences.checked = false;
          splitSentences.disabled = true;
          splitSentences.parentElement.style.opacity = '0.5';
        } else {
          splitSentences.disabled = false;
          splitSentences.parentElement.style.opacity = '1';
        }
        saveSettings();
      });

      // Actor search
      const actorSearch = document.getElementById('actorSearch');
      actorSearch.addEventListener('input', () => {
        actorSearchTerm = actorSearch.value.toLowerCase().trim();
        renderActorList();
      });

      // History search
      const historySearch = document.getElementById('historySearch');
      historySearch.addEventListener('input', () => {
        historySearchTerm = historySearch.value.toLowerCase().trim();
        currentPage = 1; // Reset to first page on search
        renderHistory();
      });

      // File upload
      const uploadZone = document.getElementById('uploadZone');
      const audioFiles = document.getElementById('audioFiles');

      uploadZone.addEventListener('click', () => audioFiles.click());
      uploadZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadZone.classList.add('dragover');
      });
      uploadZone.addEventListener('dragleave', () => {
        uploadZone.classList.remove('dragover');
      });
      uploadZone.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadZone.classList.remove('dragover');
        handleFiles(e.dataTransfer.files);
      });
      audioFiles.addEventListener('change', () => {
        handleFiles(audioFiles.files);
      });

      // Add audio to existing actor
      const addAudioZone = document.getElementById('addAudioZone');
      const addAudioFile = document.getElementById('addAudioFile');
      addAudioZone.addEventListener('click', () => addAudioFile.click());
      addAudioFile.addEventListener('change', () => {
        if (addAudioFile.files.length > 0 && currentActorForDetails) {
          addAudioToActor(addAudioFile.files[0]);
        }
      });
    }

    async function checkBackendStatus() {
      try {
        const res = await fetch(`${API_BASE}/health`);
        const data = await res.json();
        statusDot.classList.remove('loading');
        statusDot.classList.add('connected');
        const audioModels = data.available_audio_models || [];
        statusText.textContent = audioModels.includes('xtts-v2') ? 'XTTS-v2 available' : 'Connected';
      } catch (e) {
        statusDot.classList.remove('connected');
        statusText.textContent = 'Disconnected';
      }
    }

    async function loadActors() {
      try {
        const res = await fetch(`${API_BASE}/actors`);
        const data = await res.json();
        actors = data.actors || [];
        renderActorSelect();
        renderActorList();
      } catch (e) {
        console.error('Failed to load actors:', e);
      }
    }

    function renderActorSelect() {
      actorSelect.innerHTML = '<option value="">Select an actor...</option>';
      actors.forEach(actor => {
        const opt = document.createElement('option');
        opt.value = actor.name;
        opt.textContent = `${actor.name} (${actor.language})`;
        actorSelect.appendChild(opt);
      });
      if (selectedActorName) {
        actorSelect.value = selectedActorName;
      }
    }

    function getFilteredActors() {
      if (!actorSearchTerm) return actors;
      return actors.filter(actor =>
        actor.name.toLowerCase().includes(actorSearchTerm) ||
        actor.language.toLowerCase().includes(actorSearchTerm) ||
        (actor.description && actor.description.toLowerCase().includes(actorSearchTerm))
      );
    }

    function renderActorList() {
      const actorCountEl = document.getElementById('actorCount');
      const filtered = getFilteredActors();

      // Update count display
      if (actorSearchTerm && filtered.length !== actors.length) {
        actorCountEl.textContent = `${filtered.length} of ${actors.length}`;
      } else {
        actorCountEl.textContent = `${actors.length} actor${actors.length !== 1 ? 's' : ''}`;
      }

      if (actors.length === 0) {
        actorList.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üé≠</div>
            <div>No actors yet</div>
          </div>
        `;
        return;
      }

      if (filtered.length === 0) {
        actorList.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üîç</div>
            <div>No matching actors</div>
          </div>
        `;
        return;
      }

      actorList.innerHTML = filtered.map(actor => `
        <div class="actor-item" onclick="showActorDetails('${escapeHtml(actor.name)}')">
          <div class="actor-avatar">${actor.name.charAt(0).toUpperCase()}</div>
          <div class="actor-info">
            <div class="actor-name">${escapeHtml(actor.name)}</div>
            <div class="actor-meta">${actor.language.toUpperCase()} ‚Ä¢ ${actor.audio_count} audio file${actor.audio_count !== 1 ? 's' : ''}${actor.description ? ' ‚Ä¢ ' + escapeHtml(actor.description) : ''}</div>
          </div>
          <div class="actor-actions">
            <button class="btn-icon" onclick="event.stopPropagation(); selectActor('${escapeHtml(actor.name)}')" title="Use this actor">‚úì</button>
          </div>
        </div>
      `).join('');
    }

    function selectActor(name) {
      selectedActorName = name;
      actorSelect.value = name;
      switchToGenerateTab();
    }

    function switchToGenerateTab() {
      // Switch to Generate tab programmatically
      document.querySelectorAll('.controls > .tabs > .tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      document.querySelector('.controls > .tabs > .tab[data-tab="generate"]').classList.add('active');
      document.getElementById('tab-generate').classList.add('active');
    }

    // Create Actor Modal
    let currentSourceTab = 'upload';

    function showCreateActorModal() {
      document.getElementById('createActorModal').classList.add('show');
      document.getElementById('actorName').value = '';
      document.getElementById('actorDescription').value = '';
      document.getElementById('actorLanguage').value = 'en';
      document.getElementById('youtubeUrl').value = '';
      document.getElementById('youtubeValidation').innerHTML = '';
      document.getElementById('maxDuration').value = '30';
      document.getElementById('maxDurationValue').textContent = '30s';
      document.getElementById('separateVocals').checked = true;
      uploadedFiles = [];
      renderFileList();
      switchSourceTab('upload');
      document.getElementById('modalStatus').className = 'status';
    }

    function hideCreateActorModal() {
      document.getElementById('createActorModal').classList.remove('show');
    }

    function switchSourceTab(tab) {
      currentSourceTab = tab;
      document.querySelectorAll('#createActorModal .tab[data-source]').forEach(t => {
        t.classList.toggle('active', t.dataset.source === tab);
      });
      document.getElementById('sourceUpload').style.display = tab === 'upload' ? 'block' : 'none';
      document.getElementById('sourceYoutube').style.display = tab === 'youtube' ? 'block' : 'none';
    }

    // YouTube URL validation
    function isValidYoutubeUrl(url) {
      const patterns = [
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?v=([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})/,
        /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
      ];
      return patterns.some(p => p.test(url));
    }

    // Setup YouTube URL validation on input
    document.addEventListener('DOMContentLoaded', () => {
      const youtubeInput = document.getElementById('youtubeUrl');
      const validation = document.getElementById('youtubeValidation');
      const maxDuration = document.getElementById('maxDuration');
      const maxDurationValue = document.getElementById('maxDurationValue');

      if (youtubeInput) {
        youtubeInput.addEventListener('input', () => {
          const url = youtubeInput.value.trim();
          if (!url) {
            validation.innerHTML = '';
          } else if (isValidYoutubeUrl(url)) {
            validation.innerHTML = '<span style="color: var(--success);">Valid YouTube URL</span>';
          } else {
            validation.innerHTML = '<span style="color: #dc2626;">Invalid YouTube URL</span>';
          }
        });
      }

      if (maxDuration) {
        maxDuration.addEventListener('input', () => {
          maxDurationValue.textContent = maxDuration.value + 's';
        });
      }
    });

    function handleFiles(files) {
      for (const file of files) {
        if (file.type.startsWith('audio/') || /\.(wav|mp3|flac|ogg|m4a)$/i.test(file.name)) {
          uploadedFiles.push(file);
        }
      }
      renderFileList();
    }

    function renderFileList() {
      const fileList = document.getElementById('fileList');
      if (uploadedFiles.length === 0) {
        fileList.innerHTML = '';
        return;
      }
      fileList.innerHTML = uploadedFiles.map((file, i) => `
        <div class="file-item">
          <span class="file-icon">üéµ</span>
          <span class="file-name">${file.name}</span>
          <span class="file-size">${formatFileSize(file.size)}</span>
          <button class="file-remove" onclick="removeFile(${i})">&times;</button>
        </div>
      `).join('');
    }

    function removeFile(index) {
      uploadedFiles.splice(index, 1);
      renderFileList();
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    async function createActor() {
      const name = document.getElementById('actorName').value.trim();
      const language = document.getElementById('actorLanguage').value;
      const description = document.getElementById('actorDescription').value.trim();
      const modalStatus = document.getElementById('modalStatus');

      if (!name) {
        modalStatus.textContent = 'Please enter an actor name';
        modalStatus.className = 'status error';
        return;
      }

      const createBtn = document.getElementById('createActorBtn');
      createBtn.disabled = true;

      try {
        let res;

        if (currentSourceTab === 'youtube') {
          // YouTube mode
          const youtubeUrl = document.getElementById('youtubeUrl').value.trim();
          if (!youtubeUrl) {
            modalStatus.textContent = 'Please enter a YouTube URL';
            modalStatus.className = 'status error';
            createBtn.disabled = false;
            return;
          }
          if (!isValidYoutubeUrl(youtubeUrl)) {
            modalStatus.textContent = 'Invalid YouTube URL';
            modalStatus.className = 'status error';
            createBtn.disabled = false;
            return;
          }

          const maxDuration = parseFloat(document.getElementById('maxDuration').value);
          const separateVocals = document.getElementById('separateVocals').checked;

          modalStatus.textContent = 'Extracting voice from YouTube... This may take a minute.';
          modalStatus.className = 'status loading';

          res = await fetch(`${API_BASE}/actors/from-youtube`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name,
              youtube_url: youtubeUrl,
              language,
              description,
              max_duration: maxDuration,
              separate_vocals: separateVocals
            })
          });
        } else {
          // Upload mode
          if (uploadedFiles.length === 0) {
            modalStatus.textContent = 'Please upload at least one audio file';
            modalStatus.className = 'status error';
            createBtn.disabled = false;
            return;
          }

          modalStatus.textContent = 'Creating actor...';
          modalStatus.className = 'status loading';

          const formData = new FormData();
          formData.append('name', name);
          formData.append('language', language);
          formData.append('description', description);
          uploadedFiles.forEach(file => {
            formData.append('audio_files', file);
          });

          res = await fetch(`${API_BASE}/actors`, {
            method: 'POST',
            body: formData
          });
        }

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || 'Failed to create actor');
        }

        modalStatus.textContent = 'Actor created successfully!';
        modalStatus.className = 'status success';

        await loadActors();
        selectedActorName = name;
        actorSelect.value = name;
        saveSettings();

        setTimeout(() => {
          hideCreateActorModal();
          // Switch to Generate tab so user can immediately use the new actor
          switchToGenerateTab();
        }, 1000);

      } catch (e) {
        modalStatus.textContent = e.message;
        modalStatus.className = 'status error';
      } finally {
        createBtn.disabled = false;
      }
    }

    // Actor Details Modal
    async function showActorDetails(name) {
      const actor = actors.find(a => a.name === name);
      if (!actor) return;

      currentActorForDetails = actor;

      document.getElementById('actorDetailsName').textContent = actor.name;
      document.getElementById('actorDetailsLang').textContent = getLanguageName(actor.language);
      document.getElementById('actorDetailsDesc').textContent = actor.description || 'No description';

      // Load audio files
      try {
        const res = await fetch(`${API_BASE}/actors/${encodeURIComponent(name)}/audio`);
        const audioFiles = await res.json();

        document.getElementById('actorAudioFiles').innerHTML = audioFiles.map(f => `
          <div class="file-item">
            <span class="file-icon">üéµ</span>
            <span class="file-name">${f.original_name || f.filename}</span>
            <span class="file-size">${f.duration_seconds ? f.duration_seconds.toFixed(1) + 's' : ''}</span>
            <button class="file-remove" onclick="downloadAudioFile('${name}', '${f.id}')" title="Download" style="color: var(--text-dim);">‚¨á</button>
            <button class="file-remove" onclick="deleteAudioFile('${name}', '${f.id}')" title="Delete">&times;</button>
          </div>
        `).join('') || '<div style="color: var(--text-dim);">No audio files</div>';
      } catch (e) {
        document.getElementById('actorAudioFiles').innerHTML = '<div style="color: var(--text-dim);">Failed to load</div>';
      }

      document.getElementById('deleteActorBtn').onclick = () => deleteActor(name);
      document.getElementById('actorDetailsModal').classList.add('show');
      document.getElementById('detailsModalStatus').className = 'status';
    }

    function hideActorDetailsModal() {
      document.getElementById('actorDetailsModal').classList.remove('show');
      currentActorForDetails = null;
    }

    async function addAudioToActor(file) {
      if (!currentActorForDetails) return;

      const modalStatus = document.getElementById('detailsModalStatus');
      modalStatus.textContent = 'Uploading audio...';
      modalStatus.className = 'status loading';

      try {
        const formData = new FormData();
        formData.append('audio_file', file);

        const res = await fetch(`${API_BASE}/actors/${encodeURIComponent(currentActorForDetails.name)}/audio`, {
          method: 'POST',
          body: formData
        });

        if (!res.ok) {
          throw new Error('Failed to upload audio');
        }

        modalStatus.textContent = 'Audio added successfully!';
        modalStatus.className = 'status success';

        await loadActors();
        showActorDetails(currentActorForDetails.name);

      } catch (e) {
        modalStatus.textContent = e.message;
        modalStatus.className = 'status error';
      }

      document.getElementById('addAudioFile').value = '';
    }

    async function deleteActor(name) {
      if (!confirm(`Delete actor "${name}"? This cannot be undone.`)) return;

      const modalStatus = document.getElementById('detailsModalStatus');
      modalStatus.textContent = 'Deleting...';
      modalStatus.className = 'status loading';

      try {
        const res = await fetch(`${API_BASE}/actors/${encodeURIComponent(name)}`, {
          method: 'DELETE'
        });

        if (!res.ok) {
          throw new Error('Failed to delete actor');
        }

        hideActorDetailsModal();
        await loadActors();

        if (selectedActorName === name) {
          selectedActorName = '';
          actorSelect.value = '';
        }

      } catch (e) {
        modalStatus.textContent = e.message;
        modalStatus.className = 'status error';
      }
    }

    function downloadAudioFile(actorName, fileId) {
      // Trigger download via hidden link
      const url = `${API_BASE}/actors/${encodeURIComponent(actorName)}/audio/${fileId}/download`;
      const link = document.createElement('a');
      link.href = url;
      link.download = '';  // Let server set filename
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    async function deleteAudioFile(actorName, fileId) {
      if (!confirm('Delete this audio file? This cannot be undone.')) return;

      const modalStatus = document.getElementById('detailsModalStatus');
      modalStatus.textContent = 'Deleting audio file...';
      modalStatus.className = 'status loading';

      try {
        const res = await fetch(`${API_BASE}/actors/${encodeURIComponent(actorName)}/audio/${fileId}`, {
          method: 'DELETE'
        });

        if (!res.ok) {
          throw new Error('Failed to delete audio file');
        }

        modalStatus.textContent = 'Audio file deleted!';
        modalStatus.className = 'status success';

        // Refresh the actor list and details
        await loadActors();
        showActorDetails(actorName);

      } catch (e) {
        modalStatus.textContent = e.message;
        modalStatus.className = 'status error';
      }
    }

    // Generate Speech
    async function generateSpeech() {
      const actor = actorSelect.value;
      const text = textInput.value.trim();

      if (!actor) {
        status.textContent = 'Please select an actor';
        status.className = 'status error';
        return;
      }

      if (!text) {
        status.textContent = 'Please enter some text';
        status.className = 'status error';
        return;
      }

      if (text.length > 10000) {
        status.textContent = 'Text is too long (max 10,000 characters)';
        status.className = 'status error';
        return;
      }

      generateBtn.disabled = true;
      const streaming = useStreaming.checked;
      status.textContent = streaming ? 'Streaming speech...' : 'Generating speech...';
      status.className = 'status loading';
      statusDot.classList.add('loading');

      const startTime = Date.now();
      const endpoint = streaming ? '/tts/stream' : '/tts/generate';

      try {
        const res = await fetch(`${API_BASE}${endpoint}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text,
            actor,
            language: languageSelect.value,
            speed: parseFloat(speedRange.value),
            temperature: parseFloat(tempRange.value),
            split_sentences: splitSentences.checked
          })
        });

        if (!res.ok) {
          const err = await res.json();
          throw new Error(err.detail || 'Generation failed');
        }

        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

        // Update player
        currentAudio = { url, blob, text, actor, elapsed };
        audioPlayer.src = url;
        audioPlaceholder.style.display = 'none';
        audioPlayerWrapper.style.display = 'block';
        audioInfo.innerHTML = `
          <span>Actor: ${actor}</span>
          <span>Size: ${formatFileSize(blob.size)}</span>
          <span>Generated in ${elapsed}s</span>
        `;

        // Reload history from backend (it was saved there) - only for non-streaming
        // Streaming doesn't save to history since it's for immediate playback
        if (!streaming) {
          await loadHistory();
        }

        status.textContent = `${streaming ? 'Streamed' : 'Generated'} successfully in ${elapsed}s`;
        status.className = 'status success';

        // Auto-play
        audioPlayer.play();

      } catch (e) {
        status.textContent = e.message;
        status.className = 'status error';
      } finally {
        generateBtn.disabled = false;
        statusDot.classList.remove('loading');
        checkBackendStatus();
      }
    }

    // History - now persisted in backend database
    async function loadHistory() {
      try {
        // Fetch more entries to support pagination (200 should be plenty)
        const res = await fetch(`${API_BASE}/tts/history?limit=200`);
        if (!res.ok) throw new Error('Failed to load history');
        const data = await res.json();
        history = data.entries.map(entry => ({
          id: entry.id,
          text: entry.text,
          actor: entry.actor_name,
          language: entry.language,
          timestamp: new Date(entry.created_at),
          // URL will be set when playing
          url: null,
          blob: null
        }));
        // Reset to page 1 when reloading history
        currentPage = 1;
        renderHistory();
      } catch (e) {
        console.error('Failed to load history:', e);
        renderHistory();
      }
    }

    function getFilteredHistory() {
      if (!historySearchTerm) return history;
      return history.filter(item =>
        item.text.toLowerCase().includes(historySearchTerm) ||
        item.actor.toLowerCase().includes(historySearchTerm)
      );
    }

    function renderHistory() {
      const historyCount = document.getElementById('historyCount');
      const pagination = document.getElementById('historyPagination');
      const pageInfo = document.getElementById('pageInfo');
      const prevBtn = document.getElementById('prevPageBtn');
      const nextBtn = document.getElementById('nextPageBtn');

      const filtered = getFilteredHistory();
      const totalItems = filtered.length;
      const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);

      // Update count display
      if (historySearchTerm && totalItems !== history.length) {
        historyCount.textContent = `${totalItems} of ${history.length} entries`;
      } else {
        historyCount.textContent = `${history.length} entries`;
      }

      if (totalItems === 0) {
        historyList.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">üìú</div>
            <div>${historySearchTerm ? 'No matching entries' : 'No history yet'}</div>
          </div>
        `;
        pagination.style.display = 'none';
        return;
      }

      // Ensure current page is valid
      if (currentPage > totalPages) currentPage = totalPages;
      if (currentPage < 1) currentPage = 1;

      // Get items for current page
      const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
      const endIndex = Math.min(startIndex + ITEMS_PER_PAGE, totalItems);
      const pageItems = filtered.slice(startIndex, endIndex);

      historyList.innerHTML = pageItems.map((item) => {
        // Find original index in history array for actions
        const originalIndex = history.findIndex(h => h.id === item.id);
        return `
        <div class="history-item" onclick="playFromHistory(${originalIndex})">
          <button class="history-play" onclick="event.stopPropagation(); playFromHistory(${originalIndex})">‚ñ∂</button>
          <div class="history-info">
            <div class="history-text">${escapeHtml(item.text.substring(0, 60))}${item.text.length > 60 ? '...' : ''}</div>
            <div class="history-meta">${item.actor} ‚Ä¢ ${formatTime(item.timestamp)}</div>
          </div>
          <div class="history-actions">
            <button class="history-download" onclick="event.stopPropagation(); downloadFromHistory(${originalIndex})" title="Download">‚¨á</button>
            <button class="history-delete" onclick="event.stopPropagation(); deleteHistoryEntry(${originalIndex})" title="Delete">üóë</button>
          </div>
        </div>
      `}).join('');

      // Show/hide pagination
      if (totalPages > 1) {
        pagination.style.display = 'flex';
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        prevBtn.disabled = currentPage <= 1;
        nextBtn.disabled = currentPage >= totalPages;
      } else {
        pagination.style.display = 'none';
      }
    }

    function changePage(delta) {
      const filtered = getFilteredHistory();
      const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
      const newPage = currentPage + delta;
      if (newPage >= 1 && newPage <= totalPages) {
        currentPage = newPage;
        renderHistory();
      }
    }

    async function playFromHistory(index) {
      const item = history[index];
      if (!item) return;

      // If we don't have the blob cached, fetch it from the API
      if (!item.url && item.id) {
        try {
          const res = await fetch(`${API_BASE}/tts/history/${item.id}/audio`);
          if (!res.ok) throw new Error('Failed to fetch audio');
          const blob = await res.blob();
          item.blob = blob;
          item.url = URL.createObjectURL(blob);
        } catch (e) {
          console.error('Failed to fetch audio:', e);
          status.textContent = 'Failed to load audio';
          status.className = 'status error';
          return;
        }
      }

      currentAudio = item;
      audioPlayer.src = item.url;
      audioPlaceholder.style.display = 'none';
      audioPlayerWrapper.style.display = 'block';
      audioInfo.innerHTML = `
        <span>Actor: ${item.actor}</span>
        <span>Size: ${item.blob ? formatFileSize(item.blob.size) : 'N/A'}</span>
      `;
      audioPlayer.play();
    }

    async function downloadFromHistory(index) {
      const item = history[index];
      if (!item) return;

      // If we don't have the blob cached, fetch it first
      if (!item.url && item.id) {
        try {
          const res = await fetch(`${API_BASE}/tts/history/${item.id}/audio`);
          if (!res.ok) throw new Error('Failed to fetch audio');
          const blob = await res.blob();
          item.blob = blob;
          item.url = URL.createObjectURL(blob);
        } catch (e) {
          console.error('Failed to fetch audio:', e);
          return;
        }
      }

      const link = document.createElement('a');
      link.href = item.url;
      link.download = `tts_${item.actor}_${Date.now()}.wav`;
      link.click();
    }

    async function deleteHistoryEntry(index) {
      const item = history[index];
      if (!item || !item.id) return;

      if (!confirm('Delete this history entry?')) return;

      try {
        const res = await fetch(`${API_BASE}/tts/history/${item.id}`, {
          method: 'DELETE'
        });

        if (!res.ok) throw new Error('Failed to delete');

        // Revoke URL if we have one
        if (item.url) {
          URL.revokeObjectURL(item.url);
        }

        // Remove from local array and re-render
        history.splice(index, 1);
        renderHistory();

      } catch (e) {
        console.error('Failed to delete history entry:', e);
        status.textContent = 'Failed to delete entry';
        status.className = 'status error';
      }
    }

    function downloadAudio() {
      if (!currentAudio || !currentAudio.blob) return;
      const link = document.createElement('a');
      link.href = currentAudio.url;
      link.download = `tts_${currentAudio.actor}_${Date.now()}.wav`;
      link.click();
    }

    function copyAudioInfo() {
      if (!currentAudio) return;
      const info = `Text: ${currentAudio.text}\nActor: ${currentAudio.actor}\nGenerated: ${new Date().toISOString()}`;
      navigator.clipboard.writeText(info);
    }

    // Utilities
    function getLanguageName(code) {
      const names = {
        en: 'English', es: 'Spanish', fr: 'French', de: 'German',
        it: 'Italian', pt: 'Portuguese', pl: 'Polish', tr: 'Turkish',
        ru: 'Russian', nl: 'Dutch', cs: 'Czech', ar: 'Arabic',
        'zh-cn': 'Chinese', ja: 'Japanese', hu: 'Hungarian',
        ko: 'Korean', hi: 'Hindi'
      };
      return names[code] || code;
    }

    function formatTime(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
